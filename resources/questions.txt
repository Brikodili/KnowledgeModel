1) attr, attr_reader, attr_writer, attr_acessor ( difference "attr :a" vs "attr :a, true" обьявит только один геттер, вместе с true - два метода )

2) Шаблоны проектирования ( паттерны ) - Эффективные способы решения характерных задач проектирования, в часности проектирования компьютерных програм. Паттерн не является законченным образцом проекта , который может быть прямо преобразован  в код, скорее это описание или образец для того как решить задачу, таким образом что бы это можно было использовать в различных ситуациях.

3) Полиморфизм: Классы с одинаковой спецификацией могут иметь различную реализацию.
3) Полиморфизм: Классы потомки могут изменять реализацию метода класса-предка сохраняя его интерфейс. Полиморфизм позволяет обрабатывать обьекты классов потомков так как буде-то это один обьект, не смотря на то, что реализация их методов может отличаться.

break vs next vs return ...

Фабричный метод:
Q: What is a factory method?
A: An initialization method that creates specialized instances of a class.


---------------------------------------------------
Обьщие языковые знания:

Назовите класс, который является родоначальником всех классов.
BasicObject

Все ли в Руби является обьектом?
Методы, блоки, ключевые слова - это не обьекты. Хотя существуют Method, Proc, некоторые ключевые слова - которые относятся к обьектам.

В какой из классов подключается модуль Kernel?
A: Object

Как обозначаются константы в Руби?
Имена констант как и имена классов задаются с большой буквы, имена классов и модулей в ruby воспринимаются как константы.

Расскажите правила обявления и вызова констант в Руби.
Константу можно определить только в контексте класса (т.е. нельзя в внутри метода класса). Обратится к константе можно с помощью ИмяКласса::ИмяКонстанты.

Что такое DSL?
DSL - Domain Specific Language это API которое позволяет разработчикам решать задачи или предоставлять интерфейс на более понятном языке.  Программы, написанные с помощью хорошо продуманного DSL, легко читать, они говорят сами за себя. Классическим примером DSL является фреймворк для тестирования RSpec.

Что такое Утиная типизация ( Duck typing )?
"Если объект ходит как утка, и крякает как утка, значит он — утка". Мы работаем с обьектом на основании его поведения, а не принадлежности к классу.

Руби статический или динамический язык программирования?
Динамический, так как сравнение типов производится в рантайме.

Руби обладает сильной или слабой типизацией?
Сильная типизация, так как тип обьекта проверяется прежде чем выполнить операцию над ним.

Руби обладает явная или неявная типизацией?
Неявная так как явно-типизированные языки отличаются тем, что тип новых переменных / функций / их аргументов нужно задавать явно. А руби перекладывает эту задачу на интерпретатор.

В чем разница между оператор/statement и выражение/expression в Руби?
В Руби все операторы/statements являются выражение/expression, так как все операторы/statments возвращают значения.

---------------------------------------------------
Типы данных:

Почему употребелние строковых литералов в циклах нежелательно?
Для каждой строки создается новый обьект, даже если значение одинаково. Поэтому лучше использовать переменные или символы.

Класс String включает в себя модуль Enumerable?
Нет

Какой метод вы можете использовать для обхода по строке?
String#each_char

Какая разница между символьным литералом, таким как «?А» и строковым литералом «А»?
Разницы нет, это обе строки.

Что такое символ/symbol?
Символы являются скалярным значением обьекта. Их используют в качестве идентификаторов для отображения неизменяющихся строк что бы зафиксировать внутреннее значение.

Почему символы обычно используются в качестве хэш-ключей вместо строк?
Строки мутабильны/mutable, а символы являются постоянными/immutable. Хотя Ruby (внутри) делает неизменной копию строки при использовании в качестве хеш-ключа, сравнение двух символов быстрее, чем сравнение двух объектов String. Это также условность.

Символы неизменяемые объекты. Назовите другие неизменняемые Ruby объекты.
Fixnum

Что происходит, когда значение становится слишком большим для Fixnum?
Оно автоматически преобразуются в Bignum.

Назовите суперкласс/superclass Fixnum?
Integer

Назовите суперкласс/superclass Integer?
Numeric

Как вы можете избежать ошибок округления в классе Numeric, которые возникают при использовании двоичной арифметики с плавающей точкой?
Используя BigDecimal

Чем синтаксис «%W» отличается от «%w»  синтаксиса?
С помощью «%W» можно определить массив, содержащий строковую интерполяцию. Это подобие двойных и одинарных кавычек.

Назовите синоним метода «Hash#key?»
Hash#has_key?, Hash#include?, Hash#member?

Как задать значение по умолчанию для хэша?
Подставив значения в качестве аргументов «::new» при инициализации или изменив значения по умолчанию непосредственно с помощью метода «Hash#default». Также можно предоставить значение по умолчанию во время запроса при помощи «Hash#fetch».

В какой последовательности итерируются значения в хеше?
Hash упорядоченная коллекция состоящая из пар ключ значение. Ruby запоминает в каком порядке добавлялись ключи, поэтому можно узнать какой элемент являеться последним в хеше

Назовите синоним «Hash#[]=»?
Hash#store

Почему вы моежете безопасно использовать строку в качестве хэш-ключа?
Потому что интерпретатор делает личную копию строки, используемой в качестве хеш-ключа.

В чем отличие «Hash#fetch» и «Hash#[]» при запросе значения у хэша?
«Hash#fetch» предоставляет возможность обработки случая, когда в хэше ключа не существует

Когда вам нужно использовать «Hash#rehash»?
Если ключами хеша являются переменные, то может возникнуть ситуация, когда их значение меняется. Чтобы иметь доступ к ассоциированным с ними данным нужно вызвать данный метод, чтобы он привел ключи в соответствие с новым значеним переменных. Например, когда массив является ключем в хеше.

Назовите два варианта использования диапазонов/Range?
Сравнение, Итерация

Как внести выражение/expression в литерал Regexp?
Использование «{}», точно так же как и двойные кавычки в строке.

Назовите два варианта использования оператора «*»/splat?
Сбор аргументов из списка параметров в массив. Расщипление массива на элементы или преобразование набора в массив элементов.

Какой единственный оператор принимает три операнда?
Оператор условия «?:» ( Его иногда называют тернарный оператор стравнения «if»)

Какой оператор должен быть определен в целях реализации модуля Сравнения/Comparable?
<=>

Какая разница между «==» и «equal?»?
«==» - ввыполняет общий сравнительный анализ ( сравнение значений ) и вреализуется по-разному в отношении различных классов, а «equal?» определяется на «BasicObject» и сравнивает идентичность объекта ( вернет true, если только сравниваемые обьекты - это один и тот же обьект ). Таким образом, оператор «equal?» не должен быть перезаписан в подклассах.

Какая разница между «==» и «===»?
По отношениию к обьектам класса «Object» - идентичны, но «===» переопределен в классах «Range», «Regex», «Proc», что бы добиться более более выразительной семантики в операторе «Case»

Какая разница между «==» и «eql?»?
«eql?» выступает как альтернативное сравнение. Hash использует «eql?» для проверки хэш-ключ равенства. «eql?» в сравнении типов Numeric сравнивает не только значения но и классы. Если вы хотите расширить функционал «==» для простых типов(для которых эта функция переопределен) еще и проверкой на принадлежностью одному классу, то можно использовать «eql?»

Какой оператор более приоритетный «&&» or «and»
«&&»

Какой оператор более приоритетный «&&» or «=»
«&&»

Какой оператор более приоритетный «and» or «=»
«=»

Какой оператор более приоритетный «&&» or «||»
«&&»

Что такое модификаторы оператора (statement modifiers)?
Условие, которое следует после выполняемой части оператора. (Например «x = 1 if a == true»)

Блок «while» опеределяет новую область видимости.
Нет

Поддерживает ли в Руби оператор «case» поведение fall-through? ( Выполняеться соответствующий условию блок, а затем выполнение продолжается до конца оператора. Что бы разрешить выполнение блока кода при нескольких совпадениях.)
Нет

Блок «rescue» опеределяет новую область видимости.
Нет

Назовите приемущества оператора «case» перед оператором «elsif»?
Оператор «case» работает значительно быстрее «if» «elsif», и также более красивый при большом количестве сравнений.

Назовите приемущества оператора «elsif» перед оператором «case»?
Оператор Case может выглядеть очень запутанным при использовании нескольких значений подряд ( через запятую )

Назовите хотя бы два класса в который подключен модуль Enumerable.
Array, Hash, Range, IO...

Когда можно/нужно использовать в блоках синтаксис do/end в отличии от фигурных скобочек «{}»
Обычно «do/end» синтаксис для блока используется для отображения много-строчных выражений. Также существует альтернативная конвенция: использовать синтаксис «фигурные скобки» для блоков, которые возвращают значение, а «do/end» синтаксис для блоков, которые как-то изменяют состояние системы и не возвращают значение.

Что такое итератор?
Объект, который позволяет обходить элементы контейнера. В Ruby, итератором, считается любой метод, который использует оператор yield.

Назовите синоним Enumerable#include??
Enumerable#member?

Является ли блок объектом?
Нет, блок синтаксическая структура интерпретатора. Блок может быть преобразован в объект Proc.

Назовите синоним Enumberable#collect?
Enumberable#map

Назовите синоним Enumberable#find?
Enumberable#detect

Назовите синоним Enumberable#select?
Enumberable#find_all

Назовите противоположный метод для Enumberable#select?
Enumberable#reject

Назовите синоним Enumberable#inject?
Enumberable#reduce

Почему нужно использовать «each» а не «for/in»?
«each» - принимает блок, таким образом определяет новую область видимости. «for/in» в свою очередь пропускает наружу последний итерируемый обьект. Так же «for/in» зависит от «each», что означает что «each» более фундаментальный аспект языка. Методы итераторы, такие как «each» читаются более естественно.

Что произойдет, если блоку передать два аргумента, когда принимает он только один?
Ничего. Только первый аргумент будет передан блоку.

Почему блок называется анонимным?
Он не имеет названия. Он не существует вне его выполнения, если не преобразуется в объект Proc.

Чем вызов блока отличаться от вызова метода?
При вызове метода с большим количество аргументов Руби будет вызывать исключение. Блок будет просто игнорировать дополнительные аргументы.

??????????????? Руби поддерживает перегрузку/overloading методов? (что это мать такое?)
Нет

Как вы можете определить присутствие метода у обьекта?
Object#respond_to? или Module#method_defined?

Что значит self?
Текущий объект

Что означает знак «!» в конце метода?
То, что надо работать с таким методом очень осторожно. Методы с таким наименованием, как правило, изменяют объект-приемник.

Что такое метод мутатор?
Метод, который изменяет внутреннее состояние объекта-приемника.

Является ли метод объектом?
Нет, однако, объект Method конечно, объект

Что такое метод-предикат в контексте конвенций наименований методов Руби?
Это метод, который отвечает на вопрос, поставленный именем метода. Предикаты обычно возвращают булевое значение.

Являются ли методы экземпляра публичными/public или приватными/private?
По умолчанию они являются открытыми/public, но вы можете изменить их видимость при помощи Module#private, Module#protected или снова сделать их открытыми/public Module#public.

Когда нужно явно использовать оператор «return»?
Для преждевременного возврата из метода

Зачем нужно использовать alias?
Если нужно создать синоним для уже существующего метода, который является более читаемым или если необходимо добавление функциональности в существующий метод.

Возможно ли вызвать приватный метод обьекта получателя не из области видимости этого обьекта.
Да, Object#send

Как можно предотвратить обьект от будующих изменений?
«#freeze»

Чем вызов приватного/private метода, отличается от вызова публичного/public метода в рамках своего класса?
Приватный/Private метод должен быть вызван «функциональном» стиле, без явного указания обьекта-приемника, или текущего обьекта «self»

Могут ли методы начинаться с большой буквы?
Да, но конвенция запрещает это делать

Назовите отличия приватного/private от защищенного/protected метода.
Закрытый метод является внутренним по отношению к реализации класса, и он может быть вызван только другими экземплярами методов этого класса (или его подклассов). Подразумевается, что закрытые методы вызываются в отношении self-объекта и не могут быть вызваны в отношении объекта явным образом. Если «m» является закрытым методом, то его можно вызвать в функциональном стиле, как «m». Вызвать его в форме «оbj.m» или даже «self.m» невозможно. Защищенный метод похож на закрытый в том смысле, что он может быть вызван только из реализации класса или его подклассов. От закрытого метода он отличается тем, что может быть вызван для любого экземпляра класса в явном виде и не ограничен всего лишь неявным вызовом в отношении self-объекта.

Что такое метод Singleton?
Метод, который доступен только на одном объекте.

Как «return» из метода отличается от «return» из блока?
«return» из метода приводит к возврату из метода. «return» из блока приводит к возврату из метода, который лексически охватывает блок.

Методы класса публичные/public или приватные/private?
По умолчанию они являются публичными/public. Но вы можете изменить их область видимости при помощи Module#private_class_method или сделать их публичными - Module#public_class_method.

Если метод не содержит выражений/expression возвратит ли он значение?
Да, вернет «nil»

Если метод объявлен вне определения класса или модуля на верхнем уровне, где он будет находиться/определяться?
Он будет приватным методом инстанс-обьекта класса Object, специального обьекта «main»

Каково происхождение ключевых слов public / private / protected?
Это приватные инстанс-методы класса «Module». Так как Class подкласс Module, эти методы могут быть вызваны без явного вызова «self» обьекта.

Как определяется приватный метод класса?
Определяется метод класса и вызывается «Module#private_class_method» с символом имени метода класса вкачестве аргумента

Назовите способ «отключения» метода.
«undef method_name», «Module#remove_method», «Module#undef_method»

В чем отличие методов «Module#remove_method» и «Module#undef_method»?
«Module#remove_method» удалит определение метода из класса, но Руби все еще будет искать определение данного метода в суперклассах или миксинах. «Module#undef_method» предотвращает вызов данного метода в рамках текущего класса.

Поддерживает ли руби «обязательные именованные аргументы»?
Да. При определении метода в именованные аргументах можно не указывать значение по умолчанию, и если при вызове метода они не будут заданы, будет возбуждена ошибка.

Назовите два различных Proc обьекта.
proc и lambda

Что вы можете сказать об аргументе метода, который начинается с «&»?
Это блок кода, который можно передать любому методу в качестве неявного последнего аргумента. Методу можно передать только один блок. Он всегда идет в самом конце. Его можно задать при вызове любого метода, независимо от того, указаны в определении метода аргументы или нет.

В чем отличие proc от lambda?
«Return» в объектах «proc» приводит к выходу из вызывающего метода, а return из «lambda»-объектов приводит к выходу из самого «lambda»-объекта. У «proc» есть гибкость при задании аргументов, он закрывает глаза на недостачу и даже на избыток аргументов, а «lambda» - нет.

Должен ли обьект быть proc-обьектом, что бы знак «&» добавлялся к нему в списке параметров?
Нет, «&» добавляется перед каждый обьектом, который отвечает на метод «to_proc»

Какое отличие в вызове Proc и lambda?
lambda больше похожи на обычный метод и поэтому накладывают дополнительные ограничения на входные параметры: если lambda объявлена с двумя параметрами - то при вызове на вход должно быть передано именно 2 параметра, в противном случае будет сгенерировано иключение ArgumentError, в случае Proc-а лишние параметры будут отброшены, а недостающие заполнены значением nil.

Когда вы можете получить «LocalJumpError?»
Вы можете получить данный вид исключения, попытавшись вызвать «yield» когда блок не был задан. Так можно поймать это исключение, попытавшись сделать return из метода который уже делает return, тоесть если вы захотите вызвать return из Proc обьекта, чей лексический метод уже возвращает значение ( возвращает данный proc обьект ).

Опишите замыкание/closure в Руби.
Замыкание это обьект, который создается во время работы программы. Из тела этого обьекта доступны все переменные, которые были в контексте на момент создания замыкания

Переменые определенные в замыкании доступны после выхода из замыкания?
Нет. Переменные, определённые в замыкании, остаются для него локальными!

Возможно ли поменять контекст замыкания в Руби?
Да, контекст замыкания можно поменять используя метод «binding»

Константы публичные/public или приватные/private?
Публичные/Public

Что произойдет если вы попытаетесь обьявить константу класса из вне этого класса?
Константа будет определена, так как константы являются публично доступными и публично назначаемыми.

????????????????????????????
Чем отличаются переменные инстанса (instance variable) от переменных класса (class variable)?
Переменная класса «вызывается» в контексте обьекта класса, переменная инстанса «вызывается» в контексте инстанс метода. Переменная инстанса не может быть вызвана из вне инстанс метода.

Почему имя класса начинаеться с большой буквы?
Потому что ключевое слово «class» создает новую константу, которая ссылаеться на класс. А константы начинаються с большой буквы.

«initialize» это метод класса (class method) или инстанса (instance method)?
Метод инстанса (instance method)

В чем отличие инстансной переменной класса от переменной класса? (Инстансная переменная класса где экземпляр сам класс)
Инстансная переменная класса это инстансная переменная класса. Инстансная переменная класса не может быть использована (вызвана) внутри методов экземпляра класса.

Что такое singleton?
Класс который может иметь один(ограниченное число) инстанс(ов).

Как в руби создать singleton?
Подключив модуль Singleton.

Метод «initialize» публичный / public или приватный / private?
По умолчанию метод «initialize» приватный / private

Что делает метод «Class#allocate» ?
Выделяет место для нового инстанса класса. Возвращаемый объект является экземпляром класса

Что такое eigenclass / metaclass / синглтон-класс?
Синглтон-методы объекта (self.some_method) являются методами экземпляра (instance methods) анонимного класса (eigenclass), связанного с этим объектом

Какое отношение методы класса(class methods) имеют к методам синглтона (singleton methods)?
Методы класса(class methods) это методы синглтона (singleton methods) анонимного класса ассоциируемого с этим классом

Что значит «Class::new», где «Class» это класс «Class»?
Это метод класса обьекта «Class» который создает новые классы

Если в классе А обьявлен метод класса «m», и класс Б наследуеться от класса А, будет ли класс Б иметь доступ к классу «m»?
Нет, наследование не дает возможности доступа к методам или переменным класса другого подкласса.

????????????
Наследуются ли eigenclass-ы ( metaclass-ы ) ?
Metaclass-ы обьектов наследуются от метакласса суперкласса обьекта класса. ->>>>>>>>>>>>>> Metaclass инстанс-обьекта стоят отдельно, и не наследуются от какого-либо другого класса.

Назовите различия между «Object#dup» и «Object#clone»?
«Object#clone» копирует даже «frozen» обьекты и любые singleton - методы обьекта, а «Object#dup» - нет.

Назовите две главные функции/фичи модулей в руби?
Миксины / mixins, и пространство имен / namespaces

Могут ли модули наследоваться?
Нет

Что происходит при подключении (include) модуля к классу?
Инстанс-методы (instance methods) модуля становятся доступными в качестве инстанс-методов (instance methods) класса. Проще говоря - «include» добавляет методы модуля объекту.

Что происходит при подключении (extends) модуля к классу?
Инстанс-методы (instance methods) модуля становятся методами-синглтона класса. ( методами класса ). Проще говоря - «extend» вызывает «include» для синглтон-класса объекта.

Назовите «superclass» класса «Class»
«Module»

Почему название модуля начинается с большой буквы?
Потому что ключевое слово «module» создает новую константу, которая ссылаеться на класс. А константы начинаються с большой буквы.

Как можно проверить был ли подключен модуль к обьекту или нет?
Используя «is_a?». Например: «my_obj.is_a? MyModule»

Что делает «Module#module_function»
Он создает копию указанного метода с возможностью вызывать этот метод в качестве метода модуля и, при подключении модуля к классу, становиться доступен каждому инстансу класса.

Что такое «Struct» в Руби?
Это особый класс в Руби, который создает специфические классы содержащие только набор переменных и методы доступа к ним. Такие классы называются структурными шаблонами (structure templates).

Можем ли мы добавить свои методы в «Struct»?
Да

Чем отличаеться «Struct» от «OpenStruct»?
«OpenStruct» намного медленнее чем обычный «Struct» или класс и использует намного больше памяти. «OpenStruct» инициализирует обьект класса «OpenStruct», «Struct» создает класс. «OpenStruct» позволяет добавлять атрибуты «на лету».

В чем отличие «Object#is_a?» и «Object#instance_of?»
«Object#instance_of?» игнорирует наследование и подмешивание, т.е. возвращает true - если обьект являеться инстансом заданного класса

Если мы вызовем ключевое слово «super» без аргументов, которые принимает этот метод. Будут ли переданы хоть какие-то аргументы в метод суперкласса?
Все аргументы, которые были переданы текущему методу, будут переданы в метод суперкласса

???????????????????? Наследуются ли методы синглтона?
Нет, так как они не определены классом и не имеют никакого отношения к механизму наследования

Наследуються ли методы класса?
Да

Наследуются ли константы?
Да

«Наследуются» ли переменные класса?
???? ( только спросить все ли верно ) Нет, тут поведение / принцип отличаеться от наследования. Любое изменение переменной класса в дочернем классе / subclass приведет к изменению переменной в текущем классе / superclass и во всех остальных подклассах текущего класса.

Почему вы должны избегать использования переменных класса?
Значение переменной класса может быть изменено в любом классе из цепочки наследования, что может привести к непредсказуемому поведению в классах которые используют эти переменные.

Когда вы наследуетесь от неизвесного вам класса, чему особенно вы должны уделять внимание?
Вам следует следить за названиеями методов, так как вы можете переопределить приватные методы родительского класса. Так же следить что бы вы не перезаписали переменные класса.

Как вы можете предотвратить наследование метода из родительского класса в дочернем классе?
Воспользовавшись «undef» в дочернем классе

Можно ли рассматривать «Module#attr_reader» как пример метапрограммирования?
Да, так как он создает геттер / getter методы в момен создания класса.

Можно ли получить доступ к инстансным переменным обьекта не из контекста получателя?
Да. С помощью метод-акцесора, «Object#instance_variable_get», «BasicObject#instance_eval», «Binding#eval».

Какой метод вызывается, если метод который был вызван небыл найден?
Ближайщий «method_missing»

Как вы можете открыть «eigenclass» из текущего - ассоциативного класса?
class << self

Что такое «Binding»?
Обьект класса Binding это контекст, который включает в себя переменные, методы, и т.д. Он хранит в себе это состояние и может предоставить к нему доступ.

Что такое «reflection API» в Руби?
Это коллекция методов определенных в «Kernel», «Object», и «Module» которая позволяет программе просматривать / изменять свою структуру и состояние.

Какой вызывается метод когда константа небыла найдена?
Ближайший «const_missing»

Опишите «Module#define_method». Количество и порядок принимаемых аргументов.
«Module#define_method» принимает символ в качестве названия метода и блок (или обьект Method) в качестве тела метода.

Может ли «eval» принимать блок?
Нет, «eval» принимает строку. Хотя «Module#class_eval» и «BasicObject#instance_eval» могут принимать блоки.

Как вы можете получить ссылку на «eigenclass» класс из текущего - ассоциативного класса?
«Object#singleton_class», «eigenclass = class << self; self; end;»

Как вы можете изменить область видимости метода из вне класса?
Используя «Module#class_eval»

В чем отличие «BasicObject#instance_eval» и «BasicObject#instance_exec»?
«BasicObject#instance_exec» принимает блок, а не строку. Так же «BasicObject#instance_exec» может принимать аргументы и прокидывать их в блок, позволяя блоку выполнение в контексте получателя с использованием параметров.

Где определены «class_variable_get», «class_variable_set»?
«Module»

Где определены «instance_variable_get», «instance_variable_set»?
«Object»

Где определены «local_variables», «global_variables»?
«Kernel»

Что такое $LOAD_PATH?
Это предопределенная переменная ( «$:» синоним к «$LOAD_PATH» ), которая представляет собой массив, в котором содержаться имена каталогов и в котором при загрузке файлов производят поиск методы «load» и «require». В начальном состоянии путь загрузки содержит пути к стандартной библиотеке Ruby.

В чем отличие Kernel#require от Kernel#load?
«Kernel#require» не требует указывать расширение файлов и не загружает один и тот же файл дважды.

Имеют ли загруженные припомощи Kernel#require или Kernel#load файлы доступ к локальным переменным текущего файла?
Нет

-----------------------------------------------------------------------------------


Q: What is the difference between Kernel#require and Kernel#require_relative?
A: Kernel#require_relative ignores the load path.

Q: What does Kernel#autoload do?
A: Allows lazy-loading of files when a constant assigned to a file is first referenced.

Files

Q: What does File::expand_path do?
A: Converts a relative path to a fully qualified path.

Q: What method(s) in class Dir can be used to list the contents of a directory?
A: Dir::entries, Dir::foreach, Dir#each...

Q: What is an IO object?
A: An IO object is an instance of class IO that can be used for reading or writing binary data to and from a file.

Gems

Q: Are RubyGems installation directories included in $LOAD_PATH?
A: Yes.

Q: If more than one version of a Gem is installed, which version will be used?
A: The Gem with the highest version number.

Security

Q: What can you say about objects derived from tainted objects?
A: They will also be tainted.

Q: What is the default $SAFE level?
A: 0

Q: What happens when you attempt to lower the $SAFE level?
A: The $SAFE level cannot be lowered; it can only be raised.

Q: What is the difference between taint and trust?
A: Taint is derived from the environment such as the command line, environment variables, files, sockets, etc..., while trust is derived from the $SAFE level of the originating code. Untrusted objects are both untrusted and tainted.

Exceptions

Q: What error is raised if a method is passed the wrong number of arguments?
A: ArgumentError

Q: What error is raised if method name resolution fails?
A: NoMethodError

Q: The superclass of StandardError is __.
A: Exception

Q: What does the default implementation of BasicObject#method_missing do?
A: Raises a NoMethodError.

Q: What happens if you attempt to redefine BasicObject#__send__?
A: Ruby issues a warning.

Debugging

Q: What is the difference between #to_s and #inspect?
A: #inspect is the same as #to_s, except some classes redefine #inspect to provide output that is more helpful for debugging.

Q: What is the difference between #puts and #p?
A: #p converts objects to strings with an #inspect method and returns argument(s) as a result (useful to inject directly into the method argument list). #puts uses #to_s and returns nil.

Q: Which Ruby interpreter option enables debugging?
A: -d / --debug

Q: What is the global variable for the last exception raised?
A: $ERROR_INFO equivalent to $!

Q: How can you obtain the current state of the call stack?
A: Using Exception#backtrace (state at exception raise), Thread.current.backtrace (current state) or Kernel#caller (does not include current line)

Q: What does Kernel#__method__ return?
A: The name of the currently executing method as a symbol.

Q: What is the synonym of Kernel#__method__?
A: Kernel#__callee__ (the difference since Ruby 2.0 is that __callee__ returns the name of an aliased method, if any).

The Ruby Environment and the Interpreter

Q: What is the difference between #puts and #print?
A: #puts appends a newline character to the output. #print prints a value of special variable $_ when called without arguments.

Q: Which Ruby interpreter option allows running of one-line scripts?
A: -e

Q: Where do the curly brackets to define a hash literal {} exist in the object model?
A: It does not exist within the object model - it is a function of the interpreter.

Q: What is the default encoding in MRI?
A: UTF-8

Q: How does Ruby know that a setter method such as X#[]= should be called in the expression x.field = []?
A: It is a syntactical conversion in the interpreter.

Q: What is the global constant to access arguments specified on the command line?
A: ARGV

Q: Which Ruby interpreter option enables warnings about deprecated or problematic code?
A: -w

Q: In MRI, which objects are not subject to garbage collection?
A: Symbols, but in version 2.2 was implemented symbol GC.

Q: What module in the standard library enables English language alternatives to terse global variables?
A: English
