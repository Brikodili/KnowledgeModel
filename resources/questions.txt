1) attr, attr_reader, attr_writer, attr_acessor ( difference "attr :a" vs "attr :a, true" обьявит только один геттер, вместе с true - два метода )

2) Шаблоны проектирования ( паттерны ) - Эффективные способы решения характерных задач проектирования, в часности проектирования компьютерных програм. Паттерн не является законченным образцом проекта , который может быть прямо преобразован  в код, скорее это описание или образец для того как решить задачу, таким образом что бы это можно было использовать в различных ситуациях.

3) Полиморфизм: Классы с одинаковой спецификацией могут иметь различную реализацию.
3) Полиморфизм: Классы потомки могут изменять реализацию метода класса-предка сохраняя его интерфейс. Полиморфизм позволяет обрабатывать обьекты классов потомков так как буде-то это один обьект, не смотря на то, что реализация их методов может отличаться.

---------------------------------------------------
Обьщие языковые знания:

Назовите класс, который является родоначальником всех классов.
BasicObject

Все ли в Руби является обьектом?
Методы, блоки, ключевые слова - это не обьекты. Хотя существуют Method, Proc, некоторые ключевые слова - которые относятся к обьектам.

В какой из классов подключается модуль Kernel?
A: Object

Как обозначаются константы в Руби?
Имена констант как и имена классов задаются с большой буквы, имена классов и модулей в ruby воспринимаются как константы.

Расскажите правила обявления и вызова констант в Руби.
Константу можно определить только в контексте класса (т.е. нельзя в внутри метода класса). Обратится к константе можно с помощью ИмяКласса::ИмяКонстанты.

Что такое DSL?
DSL - Domain Specific Language это API которое позволяет разработчикам решать задачи или предоставлять интерфейс на более понятном языке.  Программы, написанные с помощью хорошо продуманного DSL, легко читать, они говорят сами за себя. Классическим примером DSL является фреймворк для тестирования RSpec.

Что такое Утиная типизация ( Duck typing )?
"Если объект ходит как утка, и крякает как утка, значит он — утка". Мы работаем с обьектом на основании его поведения, а не принадлежности к классу.

Руби статический или динамический язык программирования?
Динамический, так как сравнение типов производится в рантайме.

Руби обладает сильной или слабой типизацией?
Сильная типизация, так как тип обьекта проверяется прежде чем выполнить операцию над ним.

Руби обладает явная или неявная типизацией?
Неявная так как явно-типизированные языки отличаются тем, что тип новых переменных / функций / их аргументов нужно задавать явно. А руби перекладывает эту задачу на интерпретатор.

В чем разница между оператор/statement и выражение/expression в Руби?
В Руби все операторы/statements являются выражение/expression, так как все операторы/statments возвращают значения.

---------------------------------------------------
Типы данных:

Почему употребелние строковых литералов в циклах нежелательно?
Для каждой строки создается новый обьект, даже если значение одинаково. Поэтому лучше использовать переменные или символы.

Класс String включает в себя модуль Enumerable?
Нет

Какой метод вы можете использовать для обхода по строке?
String#each_char

Какая разница между символьным литералом, таким как «?А» и строковым литералом «А»?
Разницы нет, это обе строки.

Что такое символ/symbol?
Символы являются скалярным значением обьекта. Их используют в качестве идентификаторов для отображения неизменяющихся строк что бы зафиксировать внутреннее значение.

Почему символы обычно используются в качестве хэш-ключей вместо строк?
Строки мутабильны/mutable, а символы являются постоянными/immutable. Хотя Ruby (внутри) делает неизменной копию строки при использовании в качестве хеш-ключа, сравнение двух символов быстрее, чем сравнение двух объектов String. Это также условность.

Символы неизменяемые объекты. Назовите другие неизменняемые Ruby объекты.
Fixnum

Что происходит, когда значение становится слишком большим для Fixnum?
Оно автоматически преобразуются в Bignum.

Назовите суперкласс/superclass Fixnum?
Integer

Назовите суперкласс/superclass Integer?
Numeric

Как вы можете избежать ошибок округления в классе Numeric, которые возникают при использовании двоичной арифметики с плавающей точкой?
Используя BigDecimal

Чем синтаксис «%W» отличается от «%w»  синтаксиса?
С помощью «%W» можно определить массив, содержащий строковую интерполяцию. Это подобие двойных и одинарных кавычек.

Назовите синоним метода «Hash#key?»
Hash#has_key?, Hash#include?, Hash#member?

Как задать значение по умолчанию для хэша?
Подставив значения в качестве аргументов «::new» при инициализации или изменив значения по умолчанию непосредственно с помощью метода «Hash#default». Также можно предоставить значение по умолчанию во время запроса при помощи «Hash#fetch».

В какой последовательности итерируются значения в хеше?
The order in which they were inserted. ??????????????????? Ассоциативные массивы в Ruby неупорядоченны: массивы могут иметь любой порядок элементов.

Назовите синоним «Hash#[]=»?
Hash#store

Почему вы моежете безопасно использовать строку в качестве хэш-ключа?
Потому что интерпретатор делает личную копию строки, используемой в качестве хеш-ключа.

В чем отличие «Hash#fetch» и «Hash#[]» при запросе значения у хэша?
«Hash#fetch» предоставляет возможность обработки случая, когда в хэше ключа не существует

Когда вам нужно использовать «Hash#rehash»?
Если ключами хеша являются переменные, то может возникнуть ситуация, когда их значение меняется. Чтобы иметь доступ к ассоциированным с ними данным нужно вызвать данный метод, чтобы он привел ключи в соответствие с новым значеним переменных. Например, когда массив является ключем в хеше.

Назовите два варианта использования диапазонов/Range?
Сравнение, Итерация

Как внести выражение/expression в литерал Regexp?
Использование «{}», точно так же как и двойные кавычки в строке.

Назовите два варианта использования оператора «*»/splat?
Сбор аргументов из списка параметров в массив. Расщипление массива на элементы или преобразование набора в массив элементов.

Какой единственный оператор принимает три операнда?
Оператор условия «?:» ( Его иногда называют тернарный оператор стравнения «if»)

Какой оператор должен быть определен в целях реализации модуля Сравнения/Comparable?
<=>

Какая разница между «==» и «equal?»?
«==» - ввыполняет общий сравнительный анализ ( сравнение значений ) и вреализуется по-разному в отношении различных классов, а «equal?» определяется на «BasicObject» и сравнивает идентичность объекта ( вернет true, если только сравниваемые обьекты - это один и тот же обьект ). Таким образом, оператор «equal?» не должен быть перезаписан в подклассах.

Какая разница между «==» и «===»?
По отношениию к обьектам класса «Object» - идентичны, но «===» переопределен в классах «Range», «Regex», «Proc», что бы добиться более более выразительной семантики в операторе «Case»

Какая разница между «==» и «eql?»?
«eql?» выступает как альтернативное сравнение. Hash использует «eql?» для проверки хэш-ключ равенства. «eql?» в сравнении типов Numeric сравнивает не только значения но и классы. Если вы хотите расширить функционал «==» для простых типов(для которых эта функция переопределен) еще и проверкой на принадлежностью одному классу, то можно использовать «eql?»

Какой оператор более приоритетный «&&» or «and»
«&&»

Какой оператор более приоритетный «&&» or «=»
«&&»

Какой оператор более приоритетный «and» or «=»
«=»

Какой оператор более приоритетный «&&» or «||»
«&&»

Что такое модификаторы оператора (statement modifiers)?
Условие, которое следует после выполняемой части оператора. (Например «x = 1 if a == true»)

Блок «while» опеределяет новую область видимости.
Нет

Поддерживает ли в Руби оператор «case» поведение fall-through? ( Выполняеться соответствующий условию блок, а затем выполнение продолжается до конца оператора. Что бы разрешить выполнение блока кода при нескольких совпадениях.)
Нет

Блок «rescue» опеределяет новую область видимости.
Нет

Назовите приемущества оператора «case» перед оператором «elsif»?
Оператор «case» работает значительно быстрее «if» «elsif», и также более красивый при большом количестве сравнений.

Назовите приемущества оператора «elsif» перед оператором «case»?
Оператор Case может выглядеть очень запутанным при использовании нескольких значений подряд ( через запятую )

Назовите хотя бы два класса в который подключен модуль Enumerable.
Array, Hash, Range, IO...

Когда можно/нужно использовать в блоках синтаксис do/end в отличии от фигурных скобочек «{}»
Обычно «do/end» синтаксис для блока используется для отображения много-строчных выражений. Также существует альтернативная конвенция: использовать синтаксис «фигурные скобки» для блоков, которые возвращают значение, а «do/end» синтаксис для блоков, которые как-то изменяют состояние системы и не возвращают значение.

Что такое итератор?
Объект, который позволяет обходить элементы контейнера. В Ruby, итератором, считается любой метод, который использует оператор yield.

Назовите синоним Enumerable#include??
Enumerable#member?

Является ли блок объектом?
Нет, блок синтаксическая структура интерпретатора. Блок может быть преобразован в объект Proc.

Назовите синоним Enumberable#collect?
Enumberable#map

Назовите синоним Enumberable#find?
Enumberable#detect

Назовите синоним Enumberable#select?
Enumberable#find_all

Назовите противоположный метод для Enumberable#select?
Enumberable#reject

Назовите синоним Enumberable#inject?
Enumberable#reduce

Почему нужно использовать «each» а не «for/in»?
«each» - принимает блок, таким образом определяет новую область видимости. «for/in» в свою очередь пропускает наружу последний итерируемый обьект. Так же «for/in» зависит от «each», что означает что «each» более фундаментальный аспект языка. Методы итераторы, такие как «each» читаются более естественно.

Что произойдет, если блоку передать два аргумента, когда принимает он только один?
Ничего. Только первый аргумент будет передан блоку.

Почему блок называется анонимным?
Он не имеет названия. Он не существует вне его выполнения, если не преобразуется в объект Proc.

Чем вызов блока отличаться от вызова метода?
При вызове метода с большим количество аргументов Руби будет вызывать исключение. Блок будет просто игнорировать дополнительные аргументы.

??????????????? Руби поддерживает перегрузку/overloading методов? (что это мать такое?)
Нет

Как вы можете определить присутствие метода у обьекта?
Object#respond_to? или Module#method_defined?

Что значит self?
Текущий объект

Что означает знак «!» в конце метода?
То, что надо работать с таким методом очень осторожно. Методы с таким наименованием, как правило, изменяют объект-приемник.

Что такое метод мутатор?
Метод, который изменяет внутреннее состояние объекта-приемника.

Является ли метод объектом?
Нет, однако, объект Method конечно, объект

Что такое метод-предикат в контексте конвенций наименований методов Руби?
Это метод, который отвечает на вопрос, поставленный именем метода. Предикаты обычно возвращают булевое значение.

Являются ли методы экземпляра публичными/public или приватными/private?
По умолчанию они являются открытыми/public, но вы можете изменить их видимость при помощи Module#private, Module#protected или снова сделать их открытыми/public Module#public.

Когда нужно явно использовать оператор «return»?
Для преждевременного возврата из метода

Зачем нужно использовать alias?
Если нужно создать синоним для уже существующего метода, который является более читаемым или если необходимо добавление функциональности в существующий метод.

Возможно ли вызвать приватный метод обьекта получателя не из области видимости этого обьекта.
Да, Object#send

Как можно предотвратить обьект от будующих изменений?
«#freeze»

Чем вызов приватного/private метода, отличается от вызова публичного/public метода в рамках своего класса?
Приватный/Private метод должен быть вызван «функциональном» стиле, без явного указания обьекта-приемника, или текущего обьекта «self»

Могут ли методы начинаться с большой буквы?
Да, но конвенция запрещает это делать

Назовите отличия приватного/private от защищенного/protected метода.
Закрытый метод является внутренним по отношению к реализации класса, и он может быть вызван только другими экземплярами методов этого класса (или его подклассов). Подразумевается, что закрытые методы вызываются в отношении self-объекта и не могут быть вызваны в отношении объекта явным образом. Если «m» является закрытым методом, то его можно вызвать в функциональном стиле, как «m». Вызвать его в форме «оbj.m» или даже «self.m» невозможно. Защищенный метод похож на закрытый в том смысле, что он может быть вызван только из реализации класса или его подклассов. От закрытого метода он отличается тем, что может быть вызван для любого экземпляра класса в явном виде и не ограничен всего лишь неявным вызовом в отношении self-объекта.

Что такое метод Singleton?
Метод, который доступен только на одном объекте.

Как «return» из метода отличается от «return» из блока?
«return» из метода приводит к возврату из метода. «return» из блока приводит к возврату из метода, который лексически охватывает блок.

Методы класса публичные/public или приватные/private?
По умолчанию они являются публичными/public. Но вы можете изменить их область видимости при помощи Module#private_class_method или сделать их публичными - Module#public_class_method.

Если метод не содержит выражений/expression возвратит ли он значение?
Да, вернет «nil»

Если метод объявлен вне определения класса или модуля на верхнем уровне, где он будет находиться/определяться?
Он будет приватным методом инстанс-обьекта класса Object, специального обьекта «main»

Каково происхождение ключевых слов public / private / protected?
Это приватные инстанс-методы класса «Module». Так как Class подкласс Module, эти методы могут быть вызваны без явного вызова «self» обьекта.

Как определяется приватный метод класса?
Определяется метод класса и вызывается «Module#private_class_method» с символом имени метода класса вкачестве аргумента

Назовите способ «отключения» метода.
«undef method_name», «Module#remove_method», «Module#undef_method»

В чем отличие методов «Module#remove_method» и «Module#undef_method»?
«Module#remove_method» удалит определение метода из класса, но Руби все еще будет искать определение данного метода в суперклассах или миксинах. «Module#undef_method» предотвращает вызов данного метода в рамках текущего класса.

Поддерживает ли руби «обязательные именованные аргументы»?
Да. При определении метода в именованные аргументах можно не указывать значение по умолчанию, и если при вызове метода они не будут заданы, будет возбуждена ошибка.

Назовите два различных Proc обьекта.
proc и lambda

Что вы можете сказать об аргументе метода, который начинается с «&»?
Это блок кода, который можно передать любому методу в качестве неявного последнего аргумента. Методу можно передать только один блок. Он всегда идет в самом конце. Его можно задать при вызове любого метода, независимо от того, указаны в определении метода аргументы или нет.

В чем отличие proc от lambda?
«Return» в объектах «proc» приводит к выходу из вызывающего метода, а return из «lambda»-объектов приводит к выходу из самого «lambda»-объекта. У «proc» есть гибкость при задании аргументов, он закрывает глаза на недостачу и даже на избыток аргументов, а «lambda» - нет.

Должен ли обьект быть proc-обьектом, что бы знак «&» добавлялся к нему в списке параметров?
Нет, «&» добавляется перед каждый обьектом, который отвечает на метод «to_proc»

Какое отличие в вызове Proc и lambda?
lambda больше похожи на обычный метод и поэтому накладывают дополнительные ограничения на входные параметры: если lambda объявлена с двумя параметрами - то при вызове на вход должно быть передано именно 2 параметра, в противном случае будет сгенерировано иключение ArgumentError, в случае Proc-а лишние параметры будут отброшены, а недостающие заполнены значением nil.


------------------------------------------------------------------------------------------------------------


Q: When might you encounter a LocalJumpError?
A: You might typically encounter this exception when attempting to yield when no block is given. You might also encounter this exception when attempting to return from a method that has already returned such as if you attempt to return from a Proc object whose lexically enclosing method has already returned.

Closures

Q: Describe a closure in Ruby.
A: A closure is an object that is both an invocable function together with a variable binding. The object retains access to the local variables that were in scope at the time of the object definition.

Q: Does a closure in Ruby retain variables by value or by reference?
A: By reference; the closure also extends the lifetimes of its variables.

Q: A closure's reference to its variables is said to be dynamically bound. What does this mean?
A: The values of the variables are resolved when the Proc object is executed.

Q: Is it possible to alter a closure?
A: Yes, the binding of a closure can be altered using #binding.

Method Objects

Q: What must you first do before you can invoke an UnboundMethod object?
A: Bind it to a receiver object using UnboundMethod#bind.

Q: Are method objects closures?
A: No.

Q: How do you obtain a Method object from an existing module/class?
A: Using Object#method

Q: How do you obtain an UnboundMethod object from an existing module/class?
A: Using Module#instance_method

Constants

Q: Are constants public or private?
A: Public.

Q: What happens if you attempt to define a constant on a class from outside the class?
A: It defines successfully since constants are publicly accessible and assignable.

Q: What happens to a constant which is not assigned?
A: It does not exist.

Classes

Q: What is the difference between an instance variable and a class variable?
A: A class variable is evaluated in reference to the class object created by the enclosing class definition while an instance variable is evaluated in reference to self. Instance variables cannot be referenced outside of instance methods.

Q: Why must a class name begin with a capital letter?
A: Because the class keyword creates a new constant that refers to the class and constants begin with a capital letter.

Q: Is #initialize an instance method or a class method?
A: An instance method.

Q: What is the difference between a class variable and a class instance variable?
A: Class instance variables are instance variables of a class. Class instance variables cannot be used within instance methods.

Q: What is a singleton?
A: A class having only a single instance.

Q: How might you create a singleton?
A: By including the Singleton module.

Q: Can you define accessor methods for class instance variables?
A: Yes, if they are defined as singleton methods of the class.

Q: Can classes be nested?
A: Yes.

Q: Is #initialize public or private?
A: Private by default.

Q: What does Class#allocate do?
A: It creates an uninitialized instance of a class.

Q: What is an eigenclass?
A: An anonymous class associated with an object. An object's singleton methods are instance methods of its associated eigenclass.

Q: What is the relationship between singleton methods and class methods?
A: Class methods are singleton methods of the eigenclass associated with the class object.

Q: What is Class::new?
A: A class method of the Class object which creates new classes.

Q: If Class B is nested within Class A, and there exists a class method on A, does Class B then have access to this instance method on Class A?
A: No. Nesting one class within another does not give the inner class any special access to the methods or variables of the outer class.

Q: Are eigenclasses inherited?
A: The eigenclasses of an object are inherited from the eigenclasses of the superclass of the class object. An eigenclass of an object instance stands alone and does not inherit from any other classes.

Q: What happens to any return value of #initialize?
A: It is ignored.

Q: What is a factory method?
A: An initialization method that creates specialized instances of a class.

Q: What is the method to run initialization code on copied instances of an object?
A: #initialize_copy

Q: Does #initialize_copy override #initialize?
A: No.

Q: What does it mean that Object#dup and #clone perform shallow copies?
A: The instance variables of the copy are copied by reference rather than by value.

Q: What is the difference between Object#dup and #clone?
A: #clone copies the frozen state of an object and any singleton methods of an object while Object#dup does neither.

Modules

Q: What are two main functions of modules?
A: As mixins, as namespaces...

Q: Can a module be subclassed?
A: No.

Q: What happens when a class includes a module?
A: The instance methods of the module become instance methods of the class.

Q: What happens when an object extends a module?
A: The instance methods of the module become singleton methods on the object.

Q: What is the superclass of Class?
A: Module

Q: Why must module names begin with a capital letter?
A: Because the module keyword creates a new constant that refers to the module and constants begin with a capital letter.

Q: How would you check if a module has been included by an object?
A: Using #is_a? such as with my_obj.is_a? MyModule.

Q: What does Module#module_function do?
A: Makes class copies of the specified methods and makes instance methods private.

Structs

Q: What is a Struct in Ruby?
A: A core Ruby class that generates other classes containing accessor methods for the specified fields.

Q: Can methods be added to a Struct?
A: Yes.

Inheritance

Q: What's the difference between Object#is_a? and Object#instance_of??
A: Object#instance_of? ignores inheritance and any mixed-in modules.

Q: If the super keyword is used in a method without any arguments, which if any arguments get passed to the superclass method?
A: All arguments that were passed to the current subclass method will be passed to the superclass method.

Q: Are singleton methods inherited?
A: No, since they are not defined by a class and thus are unrelated to the inheritance mechanism.

Q: Are class methods inherited?
A: Yes.

Q: Are constants inherited?
A: Yes.

Q: Are class variables inherited?
A: No. The behavior is different than inheritance. Any alteration of a class variable by a subclass affects that class variable in the superclass and all other subclasses of the superclass.

Q: Why might you want to avoid the use of class variables?
A: Their values can be changed at any point in the inheritance chain which can cause unexpected behavior in parent classes or subclasses which use those class variables.

Q: What should you watch out for when subclassing a class that is unknown to you?
A: Overriding private methods or overwriting class variables.

Q: How might you prevent a method on a superclass from being inherited by a subclass?
A: Override the method in the subclass or undef the method in the subclass.

Metaprogramming

Q: Can Module#attr_reader be considered an example of metaprogramming?
A: Yes, since it creates getter methods at the time of the enclosing class definition.

Q: How might you access an instance variable of a receiver object from outside the scope of the receiver object?
A: With an accessor method or using Object#instance_variable_get, BasicObject#instance_eval, or Binding#eval.

Q: Which method is invoked when a method is not found?
A: The nearest #method_missing

Q: How can you open an eigenclass from within its associated class?
A: class << self

Q: What is a binding?
A: A representation of an object's variable bindings at some moment.

Q: What is Ruby's reflection API?
A: A collection of methods mostly defined by Kernel, Object, and Module that allow a program to examine its own state and structure.

Q: Which method is invoked when a constant is not found?
A: The nearest #const_missing

Q: Module#define_method accepts how many and of what types of arguments?
A: A symbol as the method name and either a block or a Method object as the method body.

Q: Can #eval accept a block?
A: No, #eval accepts a string. However, Module#class_eval and BasicObject#instance_eval can accept blocks.

Q: How might you obtain a reference to an eigenclass from within its associated class?
A: Object#singleton_class, eigenclass = class << self; self; end

Q: How might you alter method visibility from outside a class definition?
A: Using Module#class_eval

Q: What is the difference between BasicObject#instance_eval and BasicObject#instance_exec?
A: BasicObject#instance_exec can only accept a block, not a string, and it can accept arguments and pass them to the block, allowing the block to be evaluated in the context of the receiver object with parameters whose values come from the block.

Q: Where do #class_variable_get and #class_variable_set live in the object model?
A: Module

Q: Where do #instance_variable_get and #instance_variable_set live in the object model?
A: Object

Q: Where do #local_variables and #global_variables live in the object model?
A: Kernel

Loading Modules, Files, and Gems

Loading

Q: What is $LOAD_PATH?
A: A global array of strings of the directories to be searched when loading files with the load and require methods. $LOAD_PATH is equivalent to $:.

Q: What is the difference between Kernel#require and Kernel#load?
A: Kernel#require can load binary extensions. Kernel#require does not require a filename extension. Kernel#require prevents multiple loads of the same file path. Kernel#load loads the specified file at the current $SAFE level while Kernel#require loads the specified file with a $SAFE level of 0.

Q: Does a file loaded with Kernel#require or Kernel#load have access to the local variables of the referencing file?
A: No.

Q: What is the difference between Kernel#require and Kernel#require_relative?
A: Kernel#require_relative ignores the load path.

Q: What does Kernel#autoload do?
A: Allows lazy-loading of files when a constant assigned to a file is first referenced.

Files

Q: What does File::expand_path do?
A: Converts a relative path to a fully qualified path.

Q: What method(s) in class Dir can be used to list the contents of a directory?
A: Dir::entries, Dir::foreach, Dir#each...

Q: What is an IO object?
A: An IO object is an instance of class IO that can be used for reading or writing binary data to and from a file.

Gems

Q: Are RubyGems installation directories included in $LOAD_PATH?
A: Yes.

Q: If more than one version of a Gem is installed, which version will be used?
A: The Gem with the highest version number.

Security

Q: What can you say about objects derived from tainted objects?
A: They will also be tainted.

Q: What is the default $SAFE level?
A: 0

Q: What happens when you attempt to lower the $SAFE level?
A: The $SAFE level cannot be lowered; it can only be raised.

Q: What is the difference between taint and trust?
A: Taint is derived from the environment such as the command line, environment variables, files, sockets, etc..., while trust is derived from the $SAFE level of the originating code. Untrusted objects are both untrusted and tainted.

Exceptions

Q: What error is raised if a method is passed the wrong number of arguments?
A: ArgumentError

Q: What error is raised if method name resolution fails?
A: NoMethodError

Q: The superclass of StandardError is __.
A: Exception

Q: What does the default implementation of BasicObject#method_missing do?
A: Raises a NoMethodError.

Q: What happens if you attempt to redefine BasicObject#__send__?
A: Ruby issues a warning.

Debugging

Q: What is the difference between #to_s and #inspect?
A: #inspect is the same as #to_s, except some classes redefine #inspect to provide output that is more helpful for debugging.

Q: What is the difference between #puts and #p?
A: #p converts objects to strings with an #inspect method and returns argument(s) as a result (useful to inject directly into the method argument list). #puts uses #to_s and returns nil.

Q: Which Ruby interpreter option enables debugging?
A: -d / --debug

Q: What is the global variable for the last exception raised?
A: $ERROR_INFO equivalent to $!

Q: How can you obtain the current state of the call stack?
A: Using Exception#backtrace (state at exception raise), Thread.current.backtrace (current state) or Kernel#caller (does not include current line)

Q: What does Kernel#__method__ return?
A: The name of the currently executing method as a symbol.

Q: What is the synonym of Kernel#__method__?
A: Kernel#__callee__ (the difference since Ruby 2.0 is that __callee__ returns the name of an aliased method, if any).

The Ruby Environment and the Interpreter

Q: What is the difference between #puts and #print?
A: #puts appends a newline character to the output. #print prints a value of special variable $_ when called without arguments.

Q: Which Ruby interpreter option allows running of one-line scripts?
A: -e

Q: Where do the curly brackets to define a hash literal {} exist in the object model?
A: It does not exist within the object model - it is a function of the interpreter.

Q: What is the default encoding in MRI?
A: UTF-8

Q: How does Ruby know that a setter method such as X#[]= should be called in the expression x.field = []?
A: It is a syntactical conversion in the interpreter.

Q: What is the global constant to access arguments specified on the command line?
A: ARGV

Q: Which Ruby interpreter option enables warnings about deprecated or problematic code?
A: -w

Q: In MRI, which objects are not subject to garbage collection?
A: Symbols, but in version 2.2 was implemented symbol GC.

Q: What module in the standard library enables English language alternatives to terse global variables?
A: English
