# Ruby/Rails ТЕСТ

В данном приложении приведен перечень вопросов, которым вы можете воспользоваться для проверки знаний направленных на Rails.

Вопросы направленны на обьщие знания (для позиции Rails Junior).

# P.S.
Некоторые вопросы и ответы могут быть неполными или сжатыми, ввиду формата изложения материала. Но если вы нашли ошибку или неверный ответ - то прошу сообщить на адресс dmytro.vasin@gmail.com. Спасибо.

# Темы вопросов:
- [HTML & CSS (35)](#html--css)
- [JavaScript (48)](#javascript)
- [Bash (25)](#bash)
- [GIT (30)](#git)
- [Ruby (181)](#ruby)
- [Rails (75)](#rails)
- [Rake (25)](#rake)
- [SQL (80)](#sql)

### Вопросы:
#### "HTML & CSS"
<dl>
  <dt>"Position absolute vs position fixed? Чем они отличаются?"</dt>
  <dd>"Position fixed в качестве содержащего контейнера устанавливает viewport (область просмотра), а у absolute - установлен либо ближайший предок с position отличным от static, либо корневой элемент."</dd>

  <dt>"В чем отличие div от span?"</dt>
  <dd>"Div это блочный элемент (Блоки располагаются по вертикали. На прилегающих сторонах элементов действует эффект схлопывания отступов. По ширине блочные элементы занимают всё допустимое пространство. и т.д.). Span это строчный элемент (Внутрь строчных элементов допустимо помещать текст или другие строчные элементы. Вставлять блочные элементы внутрь строчных запрещено. Эффект схлопывания отступов не действует. Свойства, связанные с размерами (width, height) не применимы. Ширина равна содержимому плюс значения отступов, полей и границ. и т.д.)."</dd>

  <dt>"В чем отличие id от сlass?"</dt>
  <dd>"Разная значимость атрибутов в CSS (Id имеет больший вес, а значит стили под этим атрибутом – значительнее). Возможность проставления якорных ссылок (Использования атрибута id позволяет поставить якорную ссылку на объект страницы). Дополнительные функции id (Для атрибута id существует функция .getElementById). Запись множественных атрибутов (Одному объекту можно задать сразу несколько классов)."</dd>

  <dt>"Дайте определение CLASS:"</dt>
  <dd>"Class – определитель стиля объекта, или группы объектов на странице. Его часто применяют для повторяющихся конструкций."</dd>

  <dt>"Дайте определение ID:"</dt>
  <dd>"Id – уникальный определитель объекта. Это значит, что несколько элементов на странице не должны (не должны - но не обязаны) иметь одинаковый id."</dd>

  <dt>"Как подсчитать специфичность селекторов?"</dt>
  <dd>"Специфичность представляет собой группу из четырех чисел. Например, 0,3,1,2. Где 2(четвертая цифра) - элемент или псевдоэлемент. Где 1(третья цифра) - класс, псевдокласс или атрибут. Где 3(вторая цифра) - id. Где 0(первая цифра) - встроенные стили."</dd>

  <dt>"Как проставляеться сокращенная запись в padding-е?"</dt>
  <dd>"padding: padding-top, padding-right, padding-bottom, paddung-left"</dd>

  <dt>"Как работает vertical-align? Правила применения?"</dt>
  <dd>"vertical-align - это выравнивает элемент по вертикали относительно своего родителя. При правильной работе, оно поможет выровнять строчный элемент относительно других строчных элементов на странице. Насколько высоко или низко расположится элемент по вертикали, будет зависеть от размера соседних строчных элементов, или от свойства line-height, заданного для этой строки. Правила: 1. свойство применяется только к строчным элементам inline или строчным блокам inline-block. 2. cвойство влияет на выравнивание самого элемента, а не его содержимого. 3. Когда свойство применяется к ячейке таблицы, выравнивание влияет на содержимое ячейки, а не на неё саму."</dd>

  <dt>"Как работает z-index? Понятие «stacking context»."</dt>
  <dd>"Любые позиционированные элементы на веб-странице могут накладываться друг на друга в определенном порядке, имитируя тем самым третье измерение, перпендикулярное экрану. Каждый элемент может находиться как ниже, так и выше других объектов веб-страницы, их размещением по z-оси и управляет z-index. Это свойство работает только для элементов, у которых значение position задано как absolute, fixed или relative. Под контекстом наложения подразумеваются элементы с общими родителями, перемещающиеся вместе на передний или задний план. Блоки разных стековых контекстов не могут накладываться друг на друга, то есть взаимодействовать визуально."</dd>

  <dt>"Как работают inline-block?"</dt>
  <dd>"Inline-block дает возможность создавать блоки, ведущие себя как строчные элементы. С одной стороны, можно управлять такими блоками при помощи text-align и т.д."</dd>

  <dt>"Какие новые элементы форм введены в HTML 5 ( назовите хотя бы три )?"</dt>
  <dd>"В HTML 5 введены десять новых важных элементов форм: «Color», «Date», «Datetime-local», «Email», «Time», «Url», «Range», «Telephone», «Number», «Search»"</dd>

  <dt>"Назовите несколько способов как отцентрировать блок по высоте?"</dt>
  <dd>"Абсолютное позиционирование, применение line-height, табличная верстка, margin-padding, display: table-cell + vertical-align"</dd>

  <dt>"Назовите что именно было добавлено с HTML5?"</dt>
  <dd>"«Семантика» - в HTML5 появился ряд новых семантических тегов, позволяющих более осмысленно организовывать внутреннюю структуру веб-страниц. «Мультимедиа» - HTML5 добавляет нативную поддержку мультимедийного контента (аудио и видео) прямо в HMTL-разметке — с соответствующим API для управления воспроизведением. «Графика» - Работать с графикой на стороне клиента стало заметно проще. В HTML5 добавлен элемент canvas и специальный API на JavaScript для работы с ним, также в HTML5 официально включен тег svg, позволяющий внедрять векторную графику. «Веб-формы» - новые элементы веб-формы: как типы, так и атрибуты, позволяющие расширить возможности традиционных форм встроенными средствами без использования дополнительных библиотек — от подсказок в поле ввода (placeholder) до проверки вводимых значений. «JavaScript APIs» - для работы с графикой и мультимедиа, и др. новые возможности."</dd>

  <dt>"Опишите position relative?"</dt>
  <dd>"Относительное позиционирование (position: relative) позволяет вам использовать свойства: top, bottom, left и right, для расположения элемента относительно того места, где бы он появился при обычном позиционировании. На месте, где бы должен был находится наш блок, образуется пустое пространство."</dd>

  <dt>"Опишите основные методы вёрстки: их преимущества и недостатки."</dt>
  <dd>"Табличная и Блочная. Фиксированный дизайн (Статика) / Резиновый дизайн (Тянется при различных расширениях экрана) / Адаптивная вёрстка (Сайт будет отображаться при разных размерах экрана так, как это наиболее удобно пользователю. Но требует тщательной проработки нескольких макетов, для различных размеров экранов.)"</dd>

  <dt>"Опишите: Clear Both (CSS)"</dt>
  <dd>"Clear родственное свойство свойству float. Элемент с установленным свойством clear не будет двигаться вверх обтекая элемент с установленным свойством float, но будет смещаться вниз игнорируя обтекание. (both – запрещает обтекание объекта с обеих сторон, т.е. и слева, и справа)"</dd>

  <dt>"Опишите: Graceful Degradation"</dt>
  <dd>"Graceful degradation сфокусирована на создании веб-сайта для наиболее продвинутого браузера. Тестирование в браузерах которые разработчики считают устаревшими проводиться в последней четверти цикла разработки и часто ограничены предыдущими версиями основных браузеров (IE, Mozilla). В соответствии с этой парадигмой, пользователи старых браузеров контент получат не в лучшем виде, но все же получат. Разработчики обращают внимание на исправление только наиболее заметных ошибок, при просмотре сайта в старом браузере."</dd>

  <dt>"Опишите: Правило !important"</dt>
  <dd>"!important — это способ сделать правила, которые должны реагировать одинаково независимо о того, в какой части документа оно применяется. Правило !important будет считаться заведомо победившим при сравнивании специфичностей селекторов."</dd>

  <dt>"Опишите: Прогрессивное улучшение / Progressive Enhancement"</dt>
  <dd>"Прогрессивное улучшение — стратегия сфокусированная на контенте. Заметьте разницу: Я даже не упомянул о браузерах. Понять прогрессивное улучшение очень легко: просто начинайте думать с контента. Контент создает базу на которой располагаются слои оформления и итеративности. (Пример: Сначала мы занимаемся разметкой. Необходимо как можно более точнее и семантически правильно разметить контент с помощью HTML. Это первый и самый главный уровень. Когда первый уровень готов можно переходить ко второму. С помощью CSS придадим нашему сайту привлекательность. А JavaScript поможет нашим посетителям взаимодействовать с сайтом.)"</dd>

  <dt>"Отличие display: none vs visibility: hidden?"</dt>
  <dd>"Элемент со свойством display: none или visibility: hidden, не отображается на странице. В этом плане результат одинаковый - в коде элемент есть, а на странице нет. Но между этими двумя свойствами существует весомое отличие: первый вариант убирает элемент с потока, а второй по сути просто делает его прозрачным."</dd>

  <dt>"Примеры адаптация под экраны высокого разрешения?"</dt>
  <dd>"Использование медиазапросов для условной загрузки изображений и назначения изображений с высоким разрешением. Использование art direction (элемент picture). Использование srcset и image-set для изображений с высоким разрешением."</dd>

  <dt>"Сокращенная запись(CSS), зачем нужна и приведите пример?"</dt>
  <dd>"Свойства из одной группы свойств можно записать сокращенно. Использование краткой записи свойств селекторов существенно упрощает процесс редактирования листов стилей. Также, сокращенная запись свойств позволяет создавать более компактный файл листов стилей, делать его удобочитаемым. Пример: font, background, margin, padding, border, border-top, border-right, border-bottom, border-left, list-style"</dd>

  <dt>"Чем отличается margin от padding?"</dt>
  <dd>"Margin определяет пространство за пределами (снаружи) элемента, padding определяет пространство внутри элемента."</dd>

  <dt>"Что лучше использовать JPG? PNG? GIF?"</dt>
  <dd>"JPG - один из самых популярных форматов. Это связано с тем, что данный формат можно очень хорошо сжимать (уменьшать его размер, но при этом также ухудшается качество изображения). PNG - формат, который поддерживает прозрачность. Имеет всего 2 варианта формата: PNG-8 и PNG-24, которые отличаются между собой количеством цветов, которые они поддерживают, и размером, который занимают. GIF - популярный формат для создания анимированных изображений, также поддерживает прозрачность. Очень похож по своим характеристикам на PNG-8, поддерживает такое же количество цветов."</dd>

  <dt>"Что такое DOCTYPE и зачем он нужен?"</dt>
  <dd>"Элемент <!DOCTYPE> предназначен для указания типа текущего документа — DTD (document type definition). Это необходимо, чтобы браузер понимал, как следует интерпретировать текущую веб-страницу, поскольку HTML существует в нескольких версиях."</dd>

  <dt>"Что такое SASS, LESS. Зачем они нужны ( какую задачу решают )?"</dt>
  <dd>"SASS, LESS - это CSS-препроцессоры, позволяющий разрабатывать таблицы стилей более продуктивным и удобным способом, чем обычный CSS. Он обладает рядом динамических компонентов, которые позволяют уменьшить код, а также делают его более универсальным и масштабируемым."</dd>

  <dt>"Что такое SVG?"</dt>
  <dd>"SVG означает scalable vector graphics (масштабируемая векторная графика). Это текстовой язык графики, с помощью которого можно рисовать изображения в виде текста, линий, точек и т.п., что позволяет создавать лёгкие и быстро обрабатываемые браузером изображения."</dd>

  <dt>"Что такое float? Как он работает?"</dt>
  <dd>"Float это свойство CSS позиционирования. Свойство которое определяет, по какой стороне будет выравниваться элемент, при этом остальные элементы будут обтекать его с других сторон. Допустим, если элемент перемещается влево (использует свойство float: left), он выравнивается по левой стороне содержащего элемента, а весь последующий контент выравнивается по правой стороне (до тех пор пока не достигнет нижней границы элемента)."</dd>

  <dt>"Что такое overflow? (overflow-x, overflow-y)"</dt>
  <dd>"Свойство CSS overflow управляет отображением содержания блочного элемента, если оно целиком не помещается и выходит за область заданных размеров. overflow-x, overflow-y управляет отображением содержания блочного элемента по оси x и y соответственно"</dd>

  <dt>"Что такое reflow?"</dt>
  <dd>"Reflow - это событие, которое происходит тогда, когда произошли изменения затрагивающие содержимое, структуру документа, положение элементов и тд (Манипуляции с DOM). Возбуждаеться процесс рекурсивного обхода ветви дерева DOM, вычисляющий геометрию элементов и их положение относительно родителя. Начало обхода - изменившийся элемент, но возможно и распространение в обратном порядке. Операции reflow очень ресурсоемки и являются одной из причин замедления работы веб-приложений."</dd>

  <dt>"Что такое repaint?"</dt>
  <dd>"Repaint - это событие, которое происходит тогда, когда изменился стиль элемента, не влияющий на его размеры и положение на странице (например, background-color, border-color, visibility), браузер просто отрисовывает его заново, с учётом нового стиля."</dd>

  <dt>"Что такое БЭМ?"</dt>
  <dd>"БЭМ расшифровывается как «Блок Элемент Модификатор». Это методика именования CSS-селекторов для построения абсолютно-независимых блоков. Правила создания: БЛОК - отвечает на вопрос «Зачем нужен это блок»? ЭЛЕМЕНТ – часть блока, которая не имеет смысла вне этого блока и не может быть использована вне него. МОДИФИКАТОР - служит для изменения внешнего вида (возможно, и поведение) блока или элемента."</dd>

  <dt>"Что такое поток документа / Document flow ( HTML/CSS )? Назовите css-свойства которые могут изменять поток документа?"</dt>
  <dd>"Flow (в переводе с англ. – поток) описывает, как элементы располагаются относительно друг друга. По умолчанию родственные элементы находятся в одном потоке и их расположение на странице статично; порядок появления элементов на странице такой же, как и в коде. С помощью CSS можно перемещать элементы в отдельные потоки. Это дает больше возможностей для дизайна страницы и контроля схемы размещения элементов над кодом. «Вырвать» элемент из потока можно при помощи свойства position и float(лишь частично влияет на элемент в потоке)."</dd>

  <dt>"Что такое псевдоклассы?"</dt>
  <dd>"Псевдоклассы обычно пишут после селектора через двоеточие, чтобы определить реакцию или состояние для данного селектора. Самые известные псевдоклассы: :LINK, :HOVER, :VISITED и :ACTIVE."</dd>

  <dt>"Что такое специфичность селекторов? (СSS)"</dt>
  <dd>"Применение к одному элементу противоречащих правил приводит к соревнованию по специфичности селекторов. Специфичность определяет их приоритетность в таблице стилей. Чем специфичнее селектор, тем выше его приоритет."</dd>
</dl>

---

#### "JavaScript"
<dl>
  <dt>"Cпособы вызова функции: Что такое Apply And Call Invocation?"</dt>
  <dd>"Вызов apply и call — Apply And Call Invocation. Позволяет вручную запустить функцию, попутно снабдив ее параметрами и обозначив this. makeArray.apply( car, ["one","two" ] );</dd>

  <dt>"Cпособы вызова функции: Что такое Function Invocation"</dt>
  <dd>"Вызов функции выполняется с помощью оператора ():"</dd>

  <dt>"Cпособы вызова функции: Что такое Method Invocation?"</dt>
  <dd>"Вызов метода / Method Invocation - это когда функция является частью объекта, она называется методом. «Вызов метода» представляет из себя вызов функции, принадлежащей объекту."</dd>

  <dt>"Eсть ли разница между window и document?"</dt>
  <dd>"Да. У JavaScript есть глобальный объект и всё происходит через него. window — тот самый объект, который хранит глобальные переменные, функции, местоположение, историю. Всё находится внутри него, setTimeout, XMLHttpRequest, console и localStorage также являются частью window.Аналогично дело обстоит и с document, который является свойством объекта window и представляет DOM. Все ноды — это часть document, следовательно, вы можете использовать getElementById или addEventListener для document. Но обратите внимание, что этих методов нет в объекте window."</dd>

  <dt>"В чём особенность использования for .. in для объекта или массива?"</dt>
  <dd>"Цикл for in всегда обходит всю цепочку прототипов полностью: таким образом, чем больше прототипов (слоёв наследования) в цепочке, тем медленнее работает цикл."</dd>

  <dt>"В чём различие свойств innerHTML и outerHTML?"</dt>
  <dd>"Свойство любого DOM элемента innerHTML содержит HTML код, который находится внутри этого элемента. При установке нового значения этого свойства, внутренний HTML код рендерится браузером заново. outerHTML почти аналогичен innerHTML, разница в том, что он возвращает полный HTML элемента."</dd>

  <dt>"Есть ли что-то такое о чём нужно позаботится при использовании node.cloneNode()?"</dt>
  <dd>"При клонировании убедитесь, что вы не дублируете ID."</dd>

  <dt>"Зачем в JS писать VAR перед переменной?"</dt>
  <dd>"Если создать переменную через обычное присваивание – будет создана глобальная переменная. А вот если создать переменную с использованием слова VAR, тогда будет создана локальная переменная, которая перестает существовать после завершения работы функции."</dd>

  <dt>"Как бы вы добавили класс к элементу через селектор?"</dt>
  <dd>"Получите элемент и добавьте имя класса в classlist."</dd>

  <dt>"Как быть уверенным в том, что DOM подготовлен и можно выполнять JavaScript?"</dt>
  <dd>"Вставьте ваш скрипт в конце body элемента. Когда DOM будет готов браузер вызовет ваш script внутри тэга. Вставьте ваш код внутрь события DOMContentLoaded. Это событие будет вызываться, когда DOM полностью загружен. Наблюдайте событие в readyState для document. Состояние «complete» будет означать полную загрузку:"</dd>

  <dt>"Как остановить дальнейшее распространение события?"</dt>
  <dd>"Вызвать event.stopPropagation();"</dd>

  <dt>"Как предотвратить нажатие по ссылке?"</dt>
  <dd>"вставить preventDefault() внутри обработчика события. Однако, это не остановит дальнейшее распространение. (return false тоже подходит)"</dd>

  <dt>"Как проверить, что один элемент является дочерним другому?"</dt>
  <dd>"Перво-наперво, проверьте является ли указанный родитель прямым для ребенка. Если нет, продолжайте двигаться вверх по дереву."</dd>

  <dt>"Как реализовано наследование в JS?"</dt>
  <dd>"На уровне языка реализованно наследование на прототипах. В Java Script каждый объект может иметь ассоциацию с другим объектом – так называемый “прототип” (prototype). В случае, если поиск некоторого свойства (или метода) в исходном объекте заканчивается неудачно, интерпретатор пытается найти одноименное свойство (метод) в его прототипе, затем – в прототипе прототипа и т.д."</dd>

  <dt>"Как создать замыкание ( JS )?"</dt>
  <dd>"Замыкания - это такой приём, когда новые области видимости (например, функций) всегда имеют доступ к внешней области, в которых они были объявлены. Собственно, единственный механизм создания областей видимости в JavaScript — это и есть функции: таким образом, объявляя функцию, вы автоматически реализуете замыкания. Или, другими словами: любая объявленная функция по умолчанию ведёт себя как замыкание."</dd>

  <dt>"Как создать массив в JS?"</dt>
  <dd>"var array = [""Value 1"", ""Value 2"", ""Value 3”]; var array = new Array(""Value 1"", ""Value 2"", ""Value 3"");"</dd>

  <dt>"Как я могу запустить обработчик в фазе захвата, а не в фазе всплытия?"</dt>
  <dd>"В методах addEventListener и removeEventLister есть третий опциональный параметр. Вы можете установить его в true или false в зависимости от того хотите или нет использовать фазу захвата."</dd>

  <dt>"Какие возможны способы вызова функции?"</dt>
  <dd>"Существует четыре пути вызова функций: Вызов метода — Method Invocation. Вызов функции — Function Invocation. Вызов конструктора — Constructor Invocation. Вызов apply и call — Apply And Call Invocation."</dd>

  <dt>"Какие из объектов трактуются как false, какие как true?"</dt>
  <dd>"undefined, null - false; Все числа - true, кроме 0, NaN — false. Все строки true, кроме пустой строки """" — false. Объекты - всегда true."</dd>

  <dt>"Какие языковые конструкции в javascript создают scope?"</dt>
  <dd>"JavaScript используется область видимости на уровне функций. Блоки кода, вроде того, который у нас идёт сразу после if, не создают новую область видимости."</dd>

  <dt>"Каким образом можно предотвратить множественный вызов обработчика для одного события?"</dt>
  <dd>"Если слушатель события прикреплён к одному и тому же типу (click, keydown, и т.д.) элемента, вы можете вызвать event.stopImmediatePropagation() в первом обработчике и другие не будут выполнены."</dd>

  <dt>"Какой наибыстрейший метод для получения элемента через css селектор?"</dt>
  <dd>"Это зависит от того, что вам нужно найти. Если у вас есть ID элемента, то getElementById — это самый быстрый путь для получения элемента. Однако, вам не следует содержать много ID в вашем документе, чтобы избежать заучивания стилей. getElementsByClassName — это второй по скорости метод для получения элемента."</dd>

  <dt>"Когда вызывается window.onload?"</dt>
  <dd>"window.onload вызывается, когда DOM готов и весь контент, включая картинки, стили, фреймы и т.д. загружен."</dd>

  <dt>"Могу ли я удалить удалить обработчик события с элемента?"</dt>
  <dd>"Да. target.removeEventListener(""click"", handler)"</dd>

  <dt>"Можно ли в JS использовать функцию в качестве конструктора?"</dt>
  <dd>"var A = function() {}; var myA = new A();"</dd>

  <dt>"Назовите различные пути для получения элемента из DOM дерева?"</dt>
  <dd>"getElementById, getElementsByClassName, querySelectorAll"</dd>

  <dt>"Особенности использования this?"</dt>
  <dd>"Когда мы используем this в глобальной области видимости, она просто ссылается на глобальный объект. При вызове foo() -> this ссылается на глобальный объект. При вызове метода test.foo() this ссылается на test. Если перед вызовом функции присутствует ключевое слово new то данная функция будет действовать как конструктор, внутри такой функции this будет указывать на новый созданный Object. Когда мы используем методы call или apply - то this будет присвоено значение первого передаваемого параметра."</dd>

  <dt>"Отличия  атрибут (attribute)  от свойства (property)?"</dt>
  <dd>"Доступ к атрибутам осуществляется при помощи стандартных методов. Отличия: Могут быть только строками. Их имя нечувствительно к регистру(т.к. это HTML). Видны в innerHTML (за исключением старых IE). Все атрибуты элемента можно получить с помощью свойства attributes, которое содержит псевдо-массив объектов типа Attr."</dd>

  <dt>"Почему querySelectorAll("".my-class"") медленнее, чем getElementsByClassName(""my-class"")?"</dt>
  <dd>"querySelectorAll является универсальным методом. Он оптимизирован под различные типы селекторов. Если вы просто укажите имя класса с «.», внутри он будет использовать getElementsByClassName (может меняться в зависимости от браузера)."</dd>

  <dt>"Почему я не могу использовать forEach или похожий метод массива для NodeList?"</dt>
  <dd>"Массив и nodeList имеет параметр length и вы можете использовать цикл для прохода по элементам, но не всё так просто. Оба они унаследованы от Object. Однако, массив имеет иной прототип нежели, чем nodeList. forEach, map, и пр. включены в Array.prototype, которого не существуют для NodeList.prototype объекта. Следовательно, вы не можете использовать forEach для nodeList."</dd>

  <dt>"Чем == отличается от === ?"</dt>
  <dd>"Оператор == сравнивает на равенство, а вот === — на идентичность. Плюс оператора === состоит в том, что он не приводит два значения к одному типу"</dd>

  <dt>"Чему равна переменная а и какого она типа? ( var a = 2 +""2""; )"</dt>
  <dd>"22, тип - string."</dd>

  <dt>"Что интересного в ECMAScript 6?"</dt>
  <dd>"let — точно так же как var ограничивает видимость переменных в пределах функции, let ограничивает видимость переменных в пределах блока. const — создание read-only констант. Maps и WeakMap — для работы с объектами ключ/значение. Возможность указывать значения параметров функции по-умолчанию. Операторы сравнения is и isnt. Реструктуризующие присваивания."</dd>

  <dt>"Что представляет из себя метод объекта?"</dt>
  <dd>"Метод объкта в Java Script – это просто функция, добавленная в ассоциативный массив."</dd>

  <dt>"Что такое .call и .apply? В чем различие между .call и .apply?"</dt>
  <dd>"Методы call и apply позволяют нам определить контекст (this или, другими словами, конкретный объект) внутри вызываемой функции. Единственное отличие между двумя методами в следующем: первый параметр для обоих методов – объект (this в функции); для call в качестве остальных параметров передаются параметры вызываемой функции, а apply ожидает в качестве второго параметра получить массив, который содержит параметры вызываемой функции."</dd>

  <dt>"Что такое AJAX и как он работает?"</dt>
  <dd>"AJAX – подход к построение интерактивных пользовательских интерфейсов веб-приложений, заключающийся в “фоновом” обмене данными браузера с веб-сервером."</dd>

  <dt>"Что такое Document Object Model (DOM)?"</dt>
  <dd>"DOM – программный интерфейс, позволяющий программам получить доступ к содержимому HTML и XML-документов, а также изменять содержимое, структуру и оформление таких документов."</dd>

  <dt>"Что такое JSON?"</dt>
  <dd>"JSON – текстовый формат обмена данными, основанный на Java Script и обычно используемый именно с этим языком. JSON легко читается людьми."</dd>

  <dt>"Что такое JSONP и зачем он нужен?"</dt>
  <dd>"Формат нужен для того, чтобы иметь возможность выполнять асинхронные запросы к серверу расположенному на другом домене. Формат запроса, когда JSON заворачивается в функцию, называется JSONP («JSON with Padding»). В паттерне JSONP URL, на который указывает атрибут src тэга "script", возвращает данные JSON, обёрнутые в вызов функции. В подобном случае функция, уже определённая в среде JavaScript, может манипулировать JSON-данными. Начинка JSONP может выглядеть так:  functionCall({""Name"": ""Foo""});"</dd>

  <dt>"Что такое Polymer?"</dt>
  <dd>"Не все браузеры поддерживают возможности по созданию веб-компонентов. Однако, благодаря библиотеке Polymer, можно это исправить. Polymer обеспечивает набор Polyfills, который позволяет использовать веб-компоненты в несовместимых браузерах."</dd>

  <dt>"Что такое Web-components?"</dt>
  <dd>"Основная идея в том, чтобы позволить программистам создавать «виджеты». Фрагменты приложения, которые изолированы от документа, в который они встраиваются. Использовать виджет возможно как с помощью HTML, так и с помощью JS API. По-простому, то веб-компонента это некий выделенный в отдельный блок кусок html кода с шаблонированием, стилями и логикой."</dd>

  <dt>"Что такое defer и async?"</dt>
  <dd>"обычное состояние: когда вы вставляете стандартный тэг script (без defer и async), парсер приостанавливает парсинг до того момента, как скрипт будет скачан и выполнен. DEFER: defer в тэге script отложит выполнение скрипта. Следовательно скрипт будет выполнен когда DOM будет доступен. Важный момент, defer не поддерживается всеми современными браузерами. ASYNC: скачивание и выполнение скрипта асинхронно.Если это возможно, устанавливайте выполнение скрипта в асинхронном режиме, но обратите внимание, что async не имеет эффекта на инлайновые скрипты."</dd>

  <dt>"Что такое null и undefined? Чем отличается null от undefined?"</dt>
  <dd>"null и undefined не эквивалентны. Каждый из них является представителем своего типа. JavaScript null — это литерал и ключевое слово языка, которое представляет собой отсутствие какого-либо объекта. Другими словами, null указывает «в никуда». undefined, олицетворяет отсутствие значения как такового. Оба абсолютно неизменны, не имеют свойств и методов и не способны их иметь. Фактически, попытка обратиться к какому-нибудь свойству, или присвоить его, приведёт к ошибке TypeError. Чтобы их различать, вы можете считать undefined неожиданным отсутствием значения, а null — умышленным отсутствием значения."</dd>

  <dt>"Что такое «strict mode»?"</dt>
  <dd>"Это режим, в котором накладывается ряд ограничений на исполняемый код, что повышает безопасность и может предотвратить появление некоторых ошибок."</dd>

  <dt>"Что такое всплытие? Как браузер определяет местоположение клика?"</dt>
  <dd>"Захват: Событие клика произошло. Он начинает с window (самый низкий уровень), затем идёт в document, затем html тэг, затем body, затем table… Он пытается достичь самого высокого уровня элемента, который только возможен. Это зовётся фазой «захвата» (первая фаза). Цель: когда браузер достигнет самого элемента на котором был произведен клик, то браузер отметит если ли у этого элемента какие-либо прикрепленные обработчики. Если ничего нет, то браузер выполнил обработчик клика. Это называет фаза цели (вторая фаза). Всплытие: после вызова обработчика, прикрепленного, браузер начнёт своё путешествие обратно с window. Уровень за уровнем он будет проверять если ли на элементе обработчик на «click» и если обнаружит таковой — выполнит. Это и есть стадия всплытия (третья фаза). Заметьте, когда вы кликните на ячейку, будут исполнены все обработчики событий на click для всех родительских элементов."</dd>

  <dt>"Что такое глобальные переменные ? Как они создаются ? Какие проблемы связаны с использованием глобальных переменных?"</dt>
  <dd>"Переменные объявляются с помощью ключевого слова var. В JavaScript есть две области видимости переменной: глобальная и локальная. Переменная, которая была объявлена за пределами функции является глобальной переменной - она имеет глобальную область видимости и доступна в любом месте исходного кода. Переменная, объявленная внутри функции называется локальной. Локальная переменная создаётся и уничтожается каждый раз при вызове функции. Внутри тела функции локальная переменная имеет преимущество перед глобальной. В JavaScript объявления переменных неявно ""поднимаются"" на самый верх относительно своей области видимости."</dd>

  <dt>"Что такое метод bind?"</dt>
  <dd>"Этот метод позволяет привязать функцию к нужному контексту и даже к аргументам."</dd>

  <dt>"Является ли атрибут (attribute) аналогом свойства (property)?"</dt>
  <dd>"Узел DOM - это объект, поэтому, как и любой объект в JavaScript, он может содержать пользовательские свойства и методы. Свойства и методы видны только в JavaScript и никак не влияют на отображение соответствующего тега. Узлы DOM, с другой стороны, являются HTML-элементами, у которых есть атрибуты."</dd>
</dl>

---

#### "Bash"
<dl>
  <dt>"Как открыть историю команд в терминале, как найти и вызвать определенную команду из истории терминала?"</dt>
  <dd>"В консоли набрав history [опциональные параметры] мы получим последние 500(по умолчанию) использованных команд. Кстати, список этих комманд можно ещё глянуть и в файлике «.bash_history» - он находится в вашей домашней папке пользователя. Что бы найти определенную команду в истории терминала - нужно набрать Ctrl+R, Эта команда выведет окно поиска - просто начните набирать команду. Повторное нажатие Ctrl+R выдаст второе совпадение. Что бы выйти из поиска нажмите Ctrl+G."</dd>

  <dt>"Обясните обьединение команд в цепочки при помощи pipe ""|"" ?"</dt>
  <dd>"Дословно делает перенаправление ввода-вывода: поток стандартного вывода предыдущего процесса перенаправляется в поток стандартного ввода следующего процесса."</dd>

  <dt>"Поясните механизм прав на файлы в UNIX - чтение, запись, выполнение и группа, владелец, прочие."</dt>
  <dd>"Существует три типа прав доступа: на чтение, запись и выполнение. Права сгруппированы три по три, соответственно чтение/запись/выполнение для владельца/группы/всех_остальных. «-rw-r--r--» где Первый (считая слева) символ говорит обычный ли это файл, каталог, символьное устройство, сокет или любое другое псевдо-файловое устройство. В нашем случае - указывает на обычный файл. Следующие три символа (в данном случае это rw-) задают права доступа владельца файла. Затем идут права группы, которой принадлежит файл (r--). Последняя тройка (r--) определяет права для всех остальных. Минус означает отсутствие каких-либо прав."</dd>

  <dt>"Что делают команды: «alias»"</dt>
  <dd>"alias — встроенная команда Bash и других шеллов для сокращения команд и их последовательностей. Использование alias позволяет сэкономить времени, так что их использование вполне рекомендуется."</dd>

  <dt>"Что делают команды: «cat», «more», «less»"</dt>
  <dd>"cat - вывести содержимое файла file1 на стандартное устройсво вывода. more - постраничный вывод содержимого файла file1 на стандартное устройство вывода. less - постраничный вывод содержимого файла file1 на стандартное устройство вывода, но с возможностью пролистывания в обе стороны (вверх-вниз), поиска по содержимому и т.п."</dd>

  <dt>"Что делают команды: «chmod», «chown»"</dt>
  <dd>"Команда chmod используется для установки (изменения) прав доступа файла. Только владелец файла может менять права доступа к нему. Команда chown используется для изменения владельца файла. Только владелец файла может изменять владельца файла или root."</dd>

  <dt>"Что делают команды: «cp», «mv»"</dt>
  <dd>"cp - копирование ( скопировать отдельный файл или скопировать всю директорию ). mv - переименовать или переместить файл или директорию."</dd>

  <dt>"Что делают команды: «ln»"</dt>
  <dd>"Создает символическую или жёсткую(физическую) ссылку на файл или директорию"</dd>

  <dt>"Что делают команды: «ls»"</dt>
  <dd>"Отображает содержимое текущей директории ( с параметрами - показывает скрытые файлы / детализированное представление )"</dd>

  <dt>"Что делают команды: «man» и «info»?"</dt>
  <dd>"Предоставляют руководство по использованию команд, при помощи которой пользователь всегда может в затруднительной ситуации получить подсказку почти по любой команде системы, форматах файлов и системных вызовах."</dd>

  <dt>"Что делают команды: «mkdir»"</dt>
  <dd>"Создать директорию ( с параметрами - несколько директорий или дерево директорий )"</dd>

  <dt>"Что делают команды: «ps -ax»"</dt>
  <dd>"ps - Выводит отчет о текущих активных процессах."</dd>

  <dt>"Что делают команды: «su», «sudo»"</dt>
  <dd>"Как su, так и sudo используются для запуска команд с привилегиями root. Su переключает вас в аккаунт root и требует пароля root (вы можете ввести команду exit и снова переключиться в режим обычного пользователя). Sudo запускает с привилегиями root одну команду - она не переключает вас в аккаунт суперпользователя и не требует отдельного пароля root."</dd>

  <dt>"Что делают команды: «tar», «gzip», «bzip»"</dt>
  <dd>"Команды работа с архивом (создать, показать, распаковать)"</dd>

  <dt>"Что делают команды: «touch»"</dt>
  <dd>"Модифицировать дату и время создания файла, при его отсутствии, создать файл с указанными датой и временем"</dd>

  <dt>"Что такое «Шаблон/Маска поиска» ( Unix )?"</dt>
  <dd>"Любой поиск основан на поиске по некоторому образцу — шаблону или маске поиска. Шаблон поиска задается при помощи специальных символов: символы-джокеры или метасимволы — символы, которые используются для замены других символов или их последовательностей, приводя таким образом к символьным шаблонам. Основные такие символы известны и часто используются припоиске файлов на диске или информации в поисковиках. Например: «$ find . -iname ""*.cpp""», где «*» - заменяет любую последовательность символов, в том числе и отсутствиесимволов. «$ find . -iname ""*.?pp""», где «?» - замена одного любого символа. «$ find . -iname ""*.[cp]pp""», где «[]» - поиск символов содержащихся в скобках."</dd>

  <dt>"Что такое «Sticky bit» (он же бит закрепления в памяти) в каталогах?"</dt>
  <dd>"Каталог с установленным sticky-битом означает, что удалить файл из этого каталога может только владелец файла или суперпользователь. Другие пользователи лишаются права удалять файлы (Даже если имеют права 7 (rwx)). Установить sticky-бит в каталоге может только суперпользователь. Заметьте, что владелец может удалить sticky-бит, но не может его установить."</dd>

  <dt>"Что такое «awk»?"</dt>
  <dd>"Awk -- это полноценный язык обработки текстовой информации. Awk ""разбивает"" каждую строку на отдельные поля. По-умолчанию, поля -- это последовательности символов, отделенные друг от друга пробелами, однако имеется возможность назначения других символов, в качестве разделителя полей. Awk анализирует и обрабатывает каждое поле в отдельности. Это делает его идеальным инструментом для работы со структурированными текстовыми файлами, осбенно с таблицами."</dd>

  <dt>"Что такое «find»?"</dt>
  <dd>"Команда для поиска файлов и директорий (с параметрвами - по имени, по принадлежности к пользователю, по маске имени."</dd>

  <dt>"Что такое «grep»?"</dt>
  <dd>"global - regular expression - print. Поиск участков текста в файле(-ах), соответствующих шаблону pattern, где pattern может быть как обычной строкой, так и регулярным выражением. Если файл(ы) для поиска не задан, то команда grep работает как фильтр для устройства stdout, например в конвейере."</dd>

  <dt>"Что такое «sed»?"</dt>
  <dd>"Sed: неинтерактивный редактор текстовых файлов. Он принимает текст либо с устройства stdin, либо из текстового файла, выполняет некоторые операции над строками и затем выводит результат на устройство stdout или в файл. Как правило, в сценариях, sed используется в конвейерной обработке данных, совместно с другими командами и утилитами."</dd>

  <dt>"Что такое «tmux» и «screen»?"</dt>
  <dd>"Это терминальные мультиплексоры. Терминальные мультиплексоры позволяют одновременно работать с несколькими терминальными сессиями в одном окне. Принцип их работы заключается в следующем: терминал с множественными вкладками создается на удаленной машине; на локальной машине окно терминала делится на несколько частей, и в каждой из них могут быть запущены любые приложения и процессы."</dd>

  <dt>"Что такое «wc»?"</dt>
  <dd>"«wc» (word count — «количество слов») — unix‐утилита, выводящая число переводов строк, слов и байт для каждого указанного файла и итоговую строку."</dd>

  <dt>"Что такое управление заданиями, обьясните команды «&», «jobs», «fg», «bg», «ctrl+z»?"</dt>
  <dd>"Однако многие командные оболочки (включая bash и tcsh) имеют функции управления заданиями (job control), позволяющие запускать одновременно несколько команд или заданий (jobs) и, по мере надобности, переключаться между ними. Команда jobs выводит список процессов, которые выполняются в фоновом режиме, fg — переводит процесс в нормальный режим («на передний план» — foreground) и возобновляет работу, a bg — в фоновый. Запустить программу в фоновом режиме можно с помощью конструкции <команда> &, ctrl+z переведет задачу в suspend и поместит ее в фоновый режим."</dd>

  <dt>"Что такое цепочки команд? как работают «&&», «||»?"</dt>
  <dd>"«&&» - оператор управления для объединения двух команд таким образом, что вторая команда будет выполняться, только если первая возвратила нулевое (выполняется успешно) значение. «||» - оператор управления разделяет две команды и запускает вторую команду, только если первая команда возвратила ненулевое значение. Другими словами, если первая команда была успешной, вторая команда не запустится. Если первая команда завершилась с ошибкой, то вторая запустится."</dd>
</dl>

---

#### "GIT"
<dl>
  <dt>"«git reset --hard HEAD~3» vs «git reset --soft HEAD~3»"</dt>
  <dd>"--soft сохраняет все состояние проекта и проиндексированные файлы, сбрасывая три последних коммита ( но не теряя их - изменения внесенные тремя коммитами остаются, как будето бы вы ничего не коммитили ). --hard убивает последние n (три) коммитов как буд-то вы их никогда и не делали ( изменения внесенные в этих коммитах - удаляются )"</dd>

  <dt>"В чём разница между «git pull» и «git fetch»?"</dt>
  <dd>"«git pull» — это по сути «git fetch» после которого сразу же следуюет «git merge». «git fetch» получает изменения с сервера и сохраняет их в «refs/remotes/». Это никак не влияет на локальные ветки и текущие изменения. А «git pull» уже вливает все эти изменения в локальную копию."</dd>

  <dt>"Зачем нужна система контроля версий?"</dt>
  <dd>"Это программное обеспечение для облегчения работы с изменяющейся информацией. Системы контроля версий позволяют хранить несколько версий одного и того же документа, при необходимости, возвращаться к более ранним версиям, определять, кто и когда сделал то или иное изменение и многое другое."</dd>

  <dt>"Как на предыдущюю ветку?"</dt>
  <dd>"git checkout -"</dd>

  <dt>"Как отменить «git add» до коммита?"</dt>
  <dd>"«git reset имя_файла»"</dd>

  <dt>"Как отменить все изменения, кроме тех, что уже добавлены в индекс?"</dt>
  <dd>"git co ."</dd>

  <dt>"Как отменить коммит ( не удаляя историю )?"</dt>
  <dd>"git revert sha_of_commit"</dd>

  <dt>"Как отменить последний коммит?"</dt>
  <dd>"«git reset HEAD~1»"</dd>

  <dt>"Как отредактировать текст сообщения к последнему коммиту?"</dt>
  <dd>"git commit --amend"</dd>

  <dt>"Как переименовать локальную ветку?"</dt>
  <dd>"git branch -m oldname newname"</dd>

  <dt>"Как перенести коммит с одной ветки в другую?"</dt>
  <dd>"git cherry-pick some_hash"</dd>

  <dt>"Как перепрыгнуть на конкретный коммит?"</dt>
  <dd>"git checkout sha_коммита"</dd>

  <dt>"Как поменять коммиты местами?"</dt>
  <dd>"Напримре при помощи «git rebase -i  HEAD~3» # В открывшемся окне редактора (где вы видите pick/squash и тд). Нужно просто поменять местами порядок коммитов и не трогать/редактировать их"</dd>

  <dt>"Как посмотреть изменения внесенные отдельным коммитом?"</dt>
  <dd>"git show sha_of_commit"</dd>

  <dt>"Как посмотреть испорию коммитов?"</dt>
  <dd>"git log"</dd>

  <dt>"Как посмотреть историю изменения файла? (кто и в каком комите изменил что-то в конкретном файле?)"</dt>
  <dd>"git log -p имя_файла"</dd>

  <dt>"Как посмотреть кто последний трогал строчку в файле?"</dt>
  <dd>"git blame file_name ( git blame -L 2,+3 file_name )"</dd>

  <dt>"Как просмотреть все скрытые ветки?"</dt>
  <dd>"git branch -a"</dd>

  <dt>"Как просмотреть текущие указатели на репозиторий? ( где написано куда вы пушите? )"</dt>
  <dd>"git remote -v"</dd>

  <dt>"Как сравнить две ветки?"</dt>
  <dd>"git diff branch1..branch2"</dd>

  <dt>"Назовите преимущества «push with force» перед стандартной работой с репозиторием? сколько времени данная методика экономит лично вам?"</dt>
  <dd>"=)"</dd>

  <dt>"Отличия Merge от Rebase?"</dt>
  <dd>"Самое главное отличие - это то, что merge создает еще один коммит ( merge commit, --ff не учитываем), а rebase меняет базу для ветки и последовательно преносит коммиты на другую базу (последовательно решая конфликты). Использование Rebase является более хорошим тоном в разработке."</dd>

  <dt>"Удалить ветку на сервере?"</dt>
  <dd>"git push origin --delete имя_ветки"</dd>

  <dt>"Что такое Squash?"</dt>
  <dd>"Это один из видов итерактивного ребейса ( rebase -i ), используется для редактирования истории коммитов - сжать все свои коммиты в один или несколько коммитов ( так же можно дать им более емкое и говорящее название )"</dd>

  <dt>"Что такое «git bisect»?"</dt>
  <dd>"Команда для отладки / поиска ошибки. Команда bisect выполняет бинарный поиск по истории коммитов, и призвана помочь как можно быстрее определить, в каком коммите была внесена ошибка."</dd>

  <dt>"Что такое «git rebase -i»?"</dt>
  <dd>"Интерактивное ребазирование - Если у вас есть некоторые коммиты которые вы хотели бы модифицировать во время выполнения ребазирования, вы можете вызвать интерактивный диалог передав параметр «git rebase -i», эту команду часто используют чтобы переписать ваши коммит-объекты перед тем как выполнить push. Это простой способ разделить, слить или переупорядочить коммиты перед тем как расшарить их с другими. Вы также можете использовать его чтобы чистить коммиты."</dd>

  <dt>"Что такое «git reflog»?"</dt>
  <dd>"Эта команда показывает все коммиты сделанные на данном компьютере. С ее помощью можно по истории изменений сделанных на данном компьютере. ( вернуть ветку если удалил и т.д.)"</dd>

  <dt>"Что такое «git stash»?"</dt>
  <dd>"Это ""заначка"". Что-то вроде буфера обмена. Можно свободно сохранить изменения в памяти. Часто возникает такая ситуация, что пока вы работаете над частью своего проекта, всё находится в беспорядочном состоянии, а вам нужно переключить ветки, чтобы немного поработать над чем-то другим. Вы можете сделать грязный коммит ( и в истории он останется ) или можете скопировать все изменения в буфер а потом ( когда надо ) достать их от туда."</dd>

  <dt>"Что храниться в «.gitconfig»?"</dt>
  <dd>"Это пользовательский конфиг. Он позволяет настраивать алиасы, надстройки, цвета, команды и тд."</dd>

  <dt>"Что храниться в «.gitignore»?"</dt>
  <dd>"В .gitignore - указываются все файлы, которые мы не хотим отслеживать ( игнорировать ). Примечание: Уже добавленные файлы не будут игнорироваться."</dd>
</dl>

---

#### "Ruby"
<dl>
  <dt>"$LOAD_PATH включает в себя дирректорию с установленными Гемами / RubyGems ?"</dt>
  <dd>"Да"</dd>

  <dt>"attr_reader, attr_writer, attr_acсessor - что они делают?"</dt>
  <dd>"attr_reader - создание только методов чтения, attr_writer - создание только методов записи, attr_acсessor - создание метов чтения и записи."</dd>

  <dt>"«initialize» это метод класса (class method) или станса (instance method)?"</dt>
  <dd>"Метод станса (instance method)"</dd>

  <dt>"«Наследуются» ли переменные класса?"</dt>
  <dd>"Нет, тут поведение / принцип отличаеться от наследования. Любое изменение переменной класса в дочернем классе / subclass приведет к изменению переменной в текущем классе / superclass и во всех остальных подклассах текущего класса."</dd>

  <dt>"Блок «rescue» определяет новую область видимости."</dt>
  <dd>"Нет"</dd>

  <dt>"Блок «while» определяет новую область видимости."</dt>
  <dd>"Нет"</dd>

  <dt>"В MRI какие объекты не подпадают под сборку мусора / garbage collection?"</dt>
  <dd>"Символы, но в руби 2.2 был реализован символьный сборщик мусора / symbol GC ( инкрементальный сборщик мусора / incremental GC) )"</dd>

  <dt>"В какой из классов подключается модуль Kernel?"</dt>
  <dd>"A: Object"</dd>

  <dt>"В какой последовательности итерируются значения в хеше?"</dt>
  <dd>"Hash упорядоченная коллекция состоящая из пар ключ значение. Ruby запоминает в каком порядке добавлялись ключи, поэтому можно узнать какой элемент является последним в хеше"</dd>

  <dt>"В чем отличие Kernel#require от Kernel#load?"</dt>
  <dd>"«Kernel#require» не требует указывать расширение файлов и не загружает один и тот же файл дважды."</dd>

  <dt>"В чем отличие Kernel#require от Kernel#require_relative?"</dt>
  <dd>"Kernel#require_relative игнорирует «путь загрузки», и производит поиск библиотеки относительно текущего файла."</dd>

  <dt>"В чем отличие proc от lambda?"</dt>
  <dd>"«Return» в объектах «proc» приводит к выходу из вызывающего метода, а return из «lambda»-объектов приводит к выходу из самого «lambda»-объекта. У «proc» есть гибкость при задании аргументов, он закрывает глаза на недостачу и даже на избыток аргументов, а «lambda» - нет."</dd>

  <dt>"В чем отличие «BasicObject#instance_eval» и «BasicObject#instance_exec»?"</dt>
  <dd>"«BasicObject#instance_exec» принимает блок, а не строку. Так же «BasicObject#instance_exec» может принимать аргументы и прокидывать их в блок, позволяя блоку выполнение в контексте получателя с использованием параметров."</dd>

  <dt>"В чем отличие «Hash#fetch» и «Hash#[]» при запросе значения у хэша?"</dt>
  <dd>"«Hash#fetch» предоставляет возможность обработки случая, когда в хэше ключа не существует"</dd>

  <dt>"В чем отличие «Object#is_a?» и «Object#instance_of?»"</dt>
  <dd>"«Object#instance_of?» игнорирует наследование и подмешивание, т.е. возвращает true - если объект является инстансом заданного класса"</dd>

  <dt>"В чем отличие «puts» от «print»?"</dt>
  <dd>"«puts» добавляет символ новой строки к своему выводу."</dd>

  <dt>"В чем отличие «puts» от «p»?"</dt>
  <dd>"«p» конвертирует обьект к строке при помощи метода «inspect», результат возврата - конвертированное значение. «puts» использует «to_s» и возвращает «nil»."</dd>

  <dt>"В чем отличие «to_s» от «inspect»?"</dt>
  <dd>"«inspect» это тоже самое что и «to_s». Лишь некоторые классы переопределяют «inspect», что бы предоставить более полезную информацию для отладки."</dd>

  <dt>"В чем отличие инстансной переменной класса от переменной класса? (Инстансная переменная класса где экземпляр сам класс)"</dt>
  <dd>"Инстансная переменная класса это инстансная переменная класса. Инстансная переменная класса не может быть использована (вызвана) внутри методов экземпляра класса."</dd>

  <dt>"В чем отличие методов «Module#remove_method» и «Module#undef_method»?"</dt>
  <dd>"«Module#remove_method» удалит определение метода из класса, но Руби все еще будет искать определение данного метода в суперклассах или миксинах. «Module#undef_method» предотвращает вызов данного метода в рамках текущего класса."</dd>

  <dt>"В чем разница между оператор/statement и выражение/expression в Руби?"</dt>
  <dd>"В Руби все операторы/statements являются выражение/expression, так как все операторы/statments возвращают значения."</dd>

  <dt>"Возможно ли вызвать приватный метод обьекта получателя не из области видимости этого обьекта."</dt>
  <dd>"Да, Object#send"</dd>

  <dt>"Возможно ли поменять контекст замыкания в Руби?"</dt>
  <dd>"Да, контекст замыкания можно поменять используя метод «binding»"</dd>

  <dt>"Все ли в Руби является обьектом?"</dt>
  <dd>"Методы, блоки, ключевые слова - это не объекты. Хотя существуют Method, Proc, некоторые ключевые слова - которые относятся к объектам."</dd>

  <dt>"Где в обьектной модели находяться фигурные скобочки ( {} ), которые определяют литерал хеша?"</dt>
  <dd>"Их не существует в объектной модели - это функция интерпретатора"</dd>

  <dt>"Где определены «class_variable_get», «class_variable_set»?"</dt>
  <dd>"«Module»"</dd>

  <dt>"Где определены «instance_variable_get», «instance_variable_set»?"</dt>
  <dd>"«Object»"</dd>

  <dt>"Где определены «local_variables», «global_variables»?"</dt>
  <dd>"«Kernel»"</dd>

  <dt>"Дайте определение: шаблоны проектирования ( паттерны )?"</dt>
  <dd>"Шаблоны проектирования ( паттерны ) - Эффективные способы решения характерных задач проектирования, в частности проектирования компьютерных программ. Паттерн не является законченным образцом проекта , который может быть прямо преобразован  в код, скорее это описание или образец для того как решить задачу, таким образом что бы это можно было использовать в различных ситуациях."</dd>

  <dt>"Должен ли объект быть proc-объектом, что бы знак «&» добавлялся к нему в списке параметров?"</dt>
  <dd>"Нет, «&» добавляется перед каждый объектом, который отвечает на метод «to_proc»"</dd>

  <dt>"Если в классе А объявлен метод класса «m», и класс Б наследуется от класса А, будет ли класс Б иметь доступ к классу «m»?"</dt>
  <dd>"Нет, наследование не дает возможности доступа к методам или переменным класса другого подкласса."</dd>

  <dt>"Если метод не содержит выражений/expression возвратит ли он значение?"</dt>
  <dd>"Да, вернет «nil»"</dd>

  <dt>"Если метод объявлен вне определения класса или модуля на верхнем уровне, где он будет находиться/определяться?"</dt>
  <dd>"Он будет приватным методом инстанс-объекта класса Object, специального объекта «main»"</dd>

  <dt>"Если мы вызовем ключевое слово «super» без аргументов, которые принимает этот метод. Будут ли переданы хоть какие-то аргументы в метод суперкласса?"</dt>
  <dd>"Все аргументы, которые были переданы текущему методу, будут переданы в метод суперкласса"</dd>

  <dt>"Если установлено более одной версии гема, то какая версия будет использоваться?"</dt>
  <dd>"Будет использоваться гем с самым большим номером версии"</dd>

  <dt>"Зачем нужно использовать alias?"</dt>
  <dd>"Если нужно создать синоним для уже существующего метода, который является более читаемым или если необходимо добавление функциональности в существующий метод."</dd>

  <dt>"Имеют ли загруженные при помощи Kernel#require или Kernel#load файлы доступ к локальным переменным текущего файла?"</dt>
  <dd>"Нет"</dd>

  <dt>"Как «return» из метода отличается от «return» из блока?"</dt>
  <dd>"«return» из метода приводит к возврату из метода. «return» из блока приводит к возврату из метода, который лексически охватывает блок."</dd>

  <dt>"Как в руби создать singleton?"</dt>
  <dd>"Подключив модуль Singleton."</dd>

  <dt>"Как внести выражение/expression в литерал Regexp?"</dt>
  <dd>"Использование «{}», точно так же как и двойные кавычки в строке."</dd>

  <dt>"Как вы можете избежать ошибок округления в классе Numeric, которые возникают при использовании двоичной арифметики с плавающей точкой?"</dt>
  <dd>"Используя BigDecimal"</dd>

  <dt>"Как вы можете изменить область видимости метода из вне класса?"</dt>
  <dd>"Используя «Module#class_eval»"</dd>

  <dt>"Как вы можете определить присутствие метода у объекта?"</dt>
  <dd>"Object#respond_to? или Module#method_defined?"</dd>

  <dt>"Как вы можете открыть «eigenclass» из текущего - ассоциативного класса?"</dt>
  <dd>"class << self"</dd>

  <dt>"Как вы можете получить ссылку на «eigenclass» класс из текущего - ассоциативного класса?"</dt>
  <dd>"«Object#singleton_class», «eigenclass = class << self; self; end;»"</dd>

  <dt>"Как вы можете получить текущее состояние стека вызова?"</dt>
  <dd>"Exception#backtrace (состояние на момент вызова исключения), Thread.current.backtrace (текущее состояние), Kernel#caller ( массив строк ) или Kernel#caller_locations ( тоже самое, что и Kernel#caller, только возвращает массив специальных обьектов, у которых есть методы которые могут предоставить спец. информацию про стрек вызова)"</dd>

  <dt>"Как вы можете предотвратить наследование метода из родительского класса в дочернем классе?"</dt>
  <dd>"Воспользовавшись «undef» в дочернем классе"</dd>

  <dt>"Как задать значение по умолчанию для хэша?"</dt>
  <dd>"Подставив значения в качестве аргументов «::new» при инициализации или изменив значения по умолчанию непосредственно с помощью метода «Hash#default». Также можно предоставить значение по умолчанию во время запроса при помощи «Hash#fetch»."</dd>

  <dt>"Как можно предотвратить объект от бушующих изменений?"</dt>
  <dd>"«#freeze»"</dd>

  <dt>"Как можно проверить был ли подключен модуль к обьекту или нет?"</dt>
  <dd>"Используя «is_a?». Например: «my_obj.is_a? MyModule»"</dd>

  <dt>"Как обозначаются константы в Руби?"</dt>
  <dd>"Имена констант как и имена классов задаются с большой буквы, имена классов и модулей в ruby воспринимаются как константы."</dd>

  <dt>"Как определяется приватный метод класса?"</dt>
  <dd>"Определяется метод класса и вызывается «Module#private_class_method» с символом имени метода класса в качестве аргумента"</dd>

  <dt>"Как руби понимает, что сеттер метод: такой как - «def []=(key, value)» должен быть вызван как «test[:b] = 4»"</dt>
  <dd>"Это синтаксическое изменение производит сам интерпретатор / interpreter."</dd>

  <dt>"Какая глобальная константа позволяет получить доступ к аргументам заданным из командной строки?"</dt>
  <dd>"ARGV"</dd>

  <dt>"Какая глобальная переменная указывает на последнее вызванное исключение?"</dt>
  <dd>"$ERROR_INFO или его синоним $!"</dd>

  <dt>"Какая разница между «==» и «===»?"</dt>
  <dd>"По отношению к объектам класса «Object» - идентичны, но «===» переопределен в классах «Range», «Regex», «Proc», что бы добиться более более выразительной семантики в операторе «Case»"</dd>

  <dt>"Какая разница между «==» и «eql?»?"</dt>
  <dd>"«eql?» выступает как альтернативное сравнение. Hash использует «eql?» для проверки хэш-ключ равенства. «eql?» в сравнении типов Numeric сравнивает не только значения но и классы. Если вы хотите расширить функционал «==» для простых типов(для которых эта функция переопределен) еще и проверкой на принадлежностью одному классу, то можно использовать «eql?»"</dd>

  <dt>"Какая разница между «==» и «equal?»?"</dt>
  <dd>"«==» - выполняет общий сравнительный анализ ( сравнение значений ) и реализуется по-разному в отношении различных классов, а «equal?» определяется на «BasicObject» и сравнивает идентичность объекта ( вернет true, если только сравниваемые объекты - это один и тот же объект ). Таким образом, оператор «equal?» не должен быть перезаписан в подклассах."</dd>

  <dt>"Какая разница между символьным литералом, таким как «?А» и строковым литералом «А»?"</dt>
  <dd>"Разницы нет, это обе строки."</dd>

  <dt>"Каким будет объект, если он получил значение из «недоверенного» объекта / «tainted»?"</dt>
  <dd>"Он будет тоже помечен (установленн флаг) как «tainted»"</dd>

  <dt>"Каково происхождение ключевых слов public / private / protected?"</dt>
  <dd>"Это приватные инстанс-методы класса «Module». Так как Class подкласс Module, эти методы могут быть вызваны без явного вызова «self» объекта."</dd>

  <dt>"Какое исключение будет вызванно, если метод попытаться дернуть с не правильным количеством параметров?"</dt>
  <dd>"ArgumentError"</dd>

  <dt>"Какое исключение будет вызванно, если метода не существует?"</dt>
  <dd>"NoMethodError"</dd>

  <dt>"Какое кодирование / encoding использует MRI по умолчанию?"</dt>
  <dd>"«UTF-8»"</dd>

  <dt>"Какое отличие в вызове Proc и lambda?"</dt>
  <dd>"lambda больше похожи на обычный метод и поэтому накладывают дополнительные ограничения на входные параметры: если lambda объявлена с двумя параметрами - то при вызове на вход должно быть передано именно 2 параметра, в противном случае будет сгенерировано иключение ArgumentError, в случае Proc-а лишние параметры будут отброшены, а недостающие заполнены значением nil."</dd>

  <dt>"Какое отношение методы класса(class methods) имеют к методам синглтона (singleton methods)?"</dt>
  <dd>"Методы класса(class methods) это методы синглтона (singleton methods) анонимного класса ассоциируемого с этим классом"</dd>

  <dt>"Какой вызывается метод когда константа небыла найдена?"</dt>
  <dd>"Ближайший «const_missing»"</dd>

  <dt>"Какой единственный оператор принимает три операнда?"</dt>
  <dd>"Оператор условия «?:» ( Его иногда называют тернарный оператор сравнения «if»)"</dd>

  <dt>"Какой метод вы можете использовать для обхода по строке?"</dt>
  <dd>"String#each_char"</dd>

  <dt>"Какой метод вызывается, если метод который был вызван не был найден?"</dt>
  <dd>"Ближайший «method_missing»"</dd>

  <dt>"Какой оператор более приоритетный «&&» или «=»"</dt>
  <dd>"«&&»"</dd>

  <dt>"Какой оператор более приоритетный «&&» или «and»"</dt>
  <dd>"«&&»"</dd>

  <dt>"Какой оператор более приоритетный «&&» или «||»"</dt>
  <dd>"«&&»"</dd>

  <dt>"Какой оператор более приоритетный «and» или «=»"</dt>
  <dd>"«=»"</dd>

  <dt>"Какой оператор должен быть определен в целях реализации модуля Сравнения/Comparable?"</dt>
  <dd>"<=>"</dd>

  <dt>"Какой по умолчанию стоит уровень $SAFE?"</dt>
  <dd>"0"</dd>

  <dt>"Класс String включает в себя модуль Enumerable?"</dt>
  <dd>"Нет"</dd>

  <dt>"Когда вам нужно использовать «Hash#rehash»?"</dt>
  <dd>"Если ключами хеша являются переменные, то может возникнуть ситуация, когда их значение меняется. Чтобы иметь доступ к ассоциированным с ними данным нужно вызвать данный метод, чтобы он привел ключи в соответствие с новым значением переменных. Например, когда массив является колючем в хеше."</dd>

  <dt>"Когда вы можете получить «LocalJumpError?»"</dt>
  <dd>"Вы можете получить данный вид исключения, попытавшись вызвать «yield» когда блок не был задан. Так можно поймать это исключение, попытавшись сделать return из метода который уже делает return, т.е. если вы захотите вызвать return из Proc объекта, чей лексический метод уже возвращает значение ( возвращает данный proc объект )."</dd>

  <dt>"Когда вы наследуетесь от неизвесного вам класса, чему особенно вы должны уделять внимание?"</dt>
  <dd>"Вам следует следить за названиями методов, так как вы можете переопределить приватные методы родительского класса. Так же следить что бы вы не перезаписали переменные класса."</dd>

  <dt>"Когда можно/нужно использовать в блоках синтаксис do/end в отличии от фигурных скобочек «{}»"</dt>
  <dd>"Обычно «do/end» синтаксис для блока используется для отображения много-строчных выражений. Также существует альтернативная конвенция: использовать синтаксис «фигурные скобки» для блоков, которые возвращают значение, а «do/end» синтаксис для блоков, которые как-то изменяют состояние системы и не возвращают значение."</dd>

  <dt>"Когда нужно явно использовать оператор «return»?"</dt>
  <dd>"Для преждевременного возврата из метода"</dd>

  <dt>"Константы публичные/public или приватные/private?"</dt>
  <dd>"Публичные/Public"</dd>

  <dt>"Метод «initialize» публичный / public или приватный / private?"</dt>
  <dd>"По умолчанию метод «initialize» приватный / private"</dd>

  <dt>"Методы класса публичные/public или приватные/private?"</dt>
  <dd>"По умолчанию они являются публичными/public. Но вы можете изменить их область видимости при помощи Module#private_class_method или сделать их публичными - Module#public_class_method."</dd>

  <dt>"Могут ли методы начинаться с большой буквы?"</dt>
  <dd>"Да, но конвенция запрещает это делать"</dd>

  <dt>"Могут ли модули наследоваться?"</dt>
  <dd>"Нет"</dd>

  <dt>"Можем ли мы добавить свои методы в «Struct»?"</dt>
  <dd>"Да"</dd>

  <dt>"Может ли «eval» принимать блок?"</dt>
  <dd>"Нет, «eval» принимает строку. Хотя «Module#class_eval» и «BasicObject#instance_eval» могут принимать блоки."</dd>

  <dt>"Можно ли получить доступ к инстансным переменным объекта не из контекста получателя?"</dt>
  <dd>"Да. С помощью метод-акцесора, «Object#instance_variable_get», «BasicObject#instance_eval», «Binding#eval»."</dd>

  <dt>"Можно ли рассматривать «Module#attr_reader» как пример метапрограммирования?"</dt>
  <dd>"Да, так как он создает геттер / getter методы в момент создания класса."</dd>

  <dt>"Назовите «superclass» класса «Class»"</dt>
  <dd>"«Module»"</dd>

  <dt>"Назовите два варианта использования диапазонов/Range?"</dt>
  <dd>"Сравнение, Итерация"</dd>

  <dt>"Назовите два варианта использования оператора «*»/splat?"</dt>
  <dd>"Сбор аргументов из списка параметров в массив. Расщипление массива на элементы или преобразование набора в массив элементов."</dd>

  <dt>"Назовите два различных Proc объекта."</dt>
  <dd>"proc и lambda"</dd>

  <dt>"Назовите две главные функции/фичи модулей в руби?"</dt>
  <dd>"Миксины / mixins, и пространство имен / namespaces"</dd>

  <dt>"Назовите класс, который является родоначальником всех классов."</dt>
  <dd>"BasicObject"</dd>

  <dt>"Назовите отличия приватного/private от защищенного/protected метода."</dt>
  <dd>"Закрытый метод является внутренним по отношению к реализации класса, и он может быть вызван только другими экземплярами методов этого класса (или его подклассов). Подразумевается, что закрытые методы вызываются в отношении self-объекта и не могут быть вызваны в отношении объекта явным образом. Если «m» является закрытым методом, то его можно вызвать в функциональном стиле, как «m». Вызвать его в форме «оbj.m» или даже «self.m» невозможно. Защищенный метод похож на закрытый в том смысле, что он может быть вызван только из реализации класса или его подклассов. От закрытого метода он отличается тем, что может быть вызван для любого экземпляра класса в явном виде и не ограничен всего лишь неявным вызовом в отношении self-объекта."</dd>

  <dt>"Назовите преимущества оператора «case» перед оператором «elsif»?"</dt>
  <dd>"Оператор «case» работает значительно быстрее «if» «elsif», и также более красивый при большом количестве сравнений."</dd>

  <dt>"Назовите преимущества оператора «elsif» перед оператором «case»?"</dt>
  <dd>"Оператор Case может выглядеть очень запутанным при использовании нескольких значений подряд ( через запятую )"</dd>

  <dt>"Назовите противоположный метод для Enumberable#select?"</dt>
  <dd>"Enumberable#reject"</dd>

  <dt>"Назовите различия между «Object#dup» и «Object#clone»?"</dt>
  <dd>"«Object#clone» копирует даже «frozen» объекты и любые singleton - методы объекта, а «Object#dup» - нет."</dd>

  <dt>"Назовите разницу между taint и trust?"</dt>
  <dd>"Теперь эти методы унифицированы и выставляют один и тот же флаг. Более предпочтительным является #tainted?, а при вызове #untrusted? будут появляться ворнинги: «untrust is deprecated and its behavior is same as taint»"</dd>

  <dt>"Назовите родительский класс класса StandardError?"</dt>
  <dd>"Exception"</dd>

  <dt>"Назовите синоним Enumberable#collect?"</dt>
  <dd>"Enumberable#map"</dd>

  <dt>"Назовите синоним Enumberable#find?"</dt>
  <dd>"Enumberable#detect"</dd>

  <dt>"Назовите синоним Enumberable#inject?"</dt>
  <dd>"Enumberable#reduce"</dd>

  <dt>"Назовите синоним Enumberable#select?"</dt>
  <dd>"Enumberable#find_all"</dd>

  <dt>"Назовите синоним «Enumerable#include?»?"</dt>
  <dd>"Enumerable#member?"</dd>

  <dt>"Назовите синоним «Hash#[]=»?"</dt>
  <dd>"Hash#store"</dd>

  <dt>"Назовите синоним метода «Hash#key?»"</dt>
  <dd>"Hash#has_key?, Hash#include?, Hash#member?"</dd>

  <dt>"Назовите синоним метода «Kernel#__method__»?"</dt>
  <dd>"Kernel#__callee__ Отличие лишь в том, что «__callee__» возвращает имя алиаса ( если вызов идет через alias )."</dd>

  <dt>"Назовите способ «отключения» метода."</dt>
  <dd>"«undef method_name», «Module#remove_method», «Module#undef_method»"</dd>

  <dt>"Назовите суперкласс/superclass Fixnum?"</dt>
  <dd>"Integer"</dd>

  <dt>"Назовите суперкласс/superclass Integer?"</dt>
  <dd>"Numeric"</dd>

  <dt>"Назовите хотя бы два класса в который подключен модуль Enumerable."</dt>
  <dd>"Array, Hash, Range, IO..."</dd>

  <dt>"Назовите хотя бы один метод класса Dir, который может быть использован для обхода / итерации всех файлов в директории."</dt>
  <dd>"Dir::entries, Dir::foreach, Dir#each"</dd>

  <dt>"Наследуются ли константы?"</dt>
  <dd>"Да"</dd>

  <dt>"Наследуються ли методы класса?"</dt>
  <dd>"Да"</dd>

  <dt>"Опишите «Module#define_method». Количество и порядок принимаемых аргументов."</dt>
  <dd>"«Module#define_method» принимает символ в качестве названия метода и блок (или обьект Method) в качестве тела метода."</dd>

  <dt>"Опишите замыкание/closure в Руби."</dt>
  <dd>"Замыкание это объект, который создается во время работы программы. Из тела этого объекта доступны все переменные, которые были в контексте на момент создания замыкания"</dd>

  <dt>"Переменные определенные в замыкании доступны после выхода из замыкания?"</dt>
  <dd>"Нет. Переменные, определённые в замыкании, остаются для него локальными!"</dd>

  <dt>"Поддерживает ли в Руби оператор «case» поведение fall-through? ( Выполняется соответствующий условию блок, а затем выполнение продолжается до конца оператора. Что бы разрешить выполнение блока кода при нескольких совпадениях.)"</dt>
  <dd>"Нет"</dd>

  <dt>"Поддерживает ли руби «обязательные именованные аргументы»?"</dt>
  <dd>"Да. При определении метода в именованные аргументах можно не указывать значение по умолчанию, и если при вызове метода они не будут заданы, будет возбуждена ошибка."</dd>

  <dt>"Почему блок называется анонимным?"</dt>
  <dd>"Он не имеет названия. Он не существует вне его выполнения, если не преобразуется в объект Proc."</dd>

  <dt>"Почему вы должны избегать использования переменных класса?"</dt>
  <dd>"Значение переменной класса может быть изменено в любом классе из цепочки наследования, что может привести к непредсказуемому поведению в классах которые используют эти переменные."</dd>

  <dt>"Почему вы моежете безопасно использовать строку в качестве хэш-ключа?"</dt>
  <dd>"Потому что интерпретатор делает личную копию строки, используемой в качестве хеш-ключа."</dd>

  <dt>"Почему имя класса начинается с большой буквы?"</dt>
  <dd>"Потому что ключевое слово «class» создает новую константу, которая ссылается на класс. А константы начинаются с большой буквы."</dd>

  <dt>"Почему название модуля начинается с большой буквы?"</dt>
  <dd>"Потому что ключевое слово «module» создает новую константу, которая ссылается на класс. А константы начинаются с большой буквы."</dd>

  <dt>"Почему нужно использовать «each» а не «for/in»?"</dt>
  <dd>"«each» - принимает блок, таким образом определяет новую область видимости. «for/in» в свою очередь пропускает наружу последний итерируемый объект. Так же «for/in» зависит от «each», что означает что «each» более фундаментальный аспект языка. Методы итераторы, такие как «each» читаются более естественно."</dd>

  <dt>"Почему символы обычно используются в качестве хэш-ключей вместо строк?"</dt>
  <dd>"Строки мутабильны/mutable, а символы являются постоянными/immutable. Хотя Ruby (внутри) делает неизменной копию строки при использовании в качестве хеш-ключа, сравнение двух символов быстрее, чем сравнение двух объектов String. Это также условность."</dd>

  <dt>"Почему употребелние строковых литералов в циклах нежелательно?"</dt>
  <dd>"Для каждой строки создается новый объект, даже если значение одинаково. Поэтому лучше использовать переменные или символы."</dd>

  <dt>"Расскажите правила объявления и вызова констант в Руби."</dt>
  <dd>"Константу можно определить только в контексте класса (т.е. нельзя в внутри метода класса). Обратится к константе можно с помощью ИмяКласса::ИмяКонстанты."</dd>

  <dt>"Руби обладает сильной или слабой типизацией?"</dt>
  <dd>"Сильная типизация, так как тип обьекта проверяется прежде чем выполнить операцию над ним."</dd>

  <dt>"Руби обладает явная или неявная типизацией?"</dt>
  <dd>"Неявная так как явно-типизированные языки отличаются тем, что тип новых переменных / функций / их аргументов нужно задавать явно. А руби перекладывает эту задачу на интерпретатор."</dd>

  <dt>"Руби статический или динамический язык программирования?"</dt>
  <dd>"Динамический, так как сравнение типов производится в ран-тайме."</dd>

  <dt>"Символы неизменяемые объекты. Назовите другие неизменяемые Ruby объекты."</dt>
  <dd>"Fixnum"</dd>

  <dt>"Чем вызов блока отличаться от вызова метода?"</dt>
  <dd>"При вызове метода с большим количество аргументов Руби будет вызывать исключение. Блок будет просто игнорировать дополнительные аргументы."</dd>

  <dt>"Чем вызов приватного/private метода, отличается от вызова публичного/public метода в рамках своего класса?"</dt>
  <dd>"Приватный/Private метод должен быть вызван «функциональном» стиле, без явного указания объекта-приемника, или текущего объекта «self»"</dd>

  <dt>"Чем отличается «Struct» от «OpenStruct»?"</dt>
  <dd>"«OpenStruct» намного медленнее чем обычный «Struct» или класс и использует намного больше памяти. «OpenStruct» инициализирует объект класса «OpenStruct», «Struct» создает класс. «OpenStruct» позволяет добавлять атрибуты «на лету»."</dd>

  <dt>"Чем синтаксис «%W» отличается от «%w»  синтаксиса?"</dt>
  <dd>"С помощью «%W» можно определить массив, содержащий строковую интерполяцию. Это подобие двойных и одинарных кавычек."</dd>

  <dt>"Что будет в «a» «b» «c»? «def my_method(a, *b, **c)»"</dt>
  <dd>Вопрос: "«a» - это обычный параметр, «*b» - принимает все входящие параметры вставленные после первого аргумента и преобразовует их в массив, «**c» - принимает любой параметр написанный в формате key: value в конце вызова метода. my_method(""a"", ""b"</dd>
Ответ
  <dt>""c""</dt>
  <dd>""d"", n: ""sss"") => «[""a"", [""b"", ""c"", ""d""], {:n=>""sss""}]»"</dd>

  <dt>"Что возвращает метод «Kernel#__method__»?"</dt>
  <dd>"Имя текущего метода в качестве символа"</dd>

  <dt>"Что вы можете сказать об аргументе метода, который начинается с «&»?"</dt>
  <dd>"Это блок кода, который можно передать любому методу в качестве неявного последнего аргумента. Методу можно передать только один блок. Он всегда идет в самом конце. Его можно задать при вызове любого метода, независимо от того, указаны в определении метода аргументы или нет."</dd>

  <dt>"Что делает File::expand_path?"</dt>
  <dd>"File::expand_path принимает в качестве первого аргумента путь и возвращает строку с его абсолютным значением. ( Если второй аргумент не задан, то File::expand_path возвращает абсолютный путь до аргумента относительно исполняемого каталога (того, где запускаем файл). Второй аргумент - это точке отсчёта, относительно которой будет вычисляться абсолютное значение пути.)"</dd>

  <dt>"Что делает Kernel#autoload?"</dt>
  <dd>"Предоставляет ленивую загрузку / lazy-loading файла. Загружает файл ( используя Kernel::require ) при первом обращении к константе."</dd>

  <dt>"Что делает break (в циклах руби)?"</dt>
  <dd>"Break приводит к выходу из цикла (или итератора). Заставляет выйти из итератора, но остаться в методе — прерывает цикл или блок. Break может возвращать значение — если такого нет то вернет nil."</dd>

  <dt>"Что делает next (в циклах руби)?"</dt>
  <dd>"Next - заставляет цикл пропустить оставшуюся часть текущей итерации и перейти к следующей итерации. Next с параметрами обычно не используется. Передаёт управление в конец цикла или блока — что бы могла начаться следующая итерация."</dd>

  <dt>"Что делает redo (в циклах руби)?"</dt>
  <dd>"Redo - презапускает цикл или итерацию с самого начала (только данную итерацию)."</dd>

  <dt>"Что делает «Module#module_function»"</dt>
  <dd>"Он создает копию указанного метода с возможностью вызывать этот метод в качестве метода модуля и, при подключении модуля к классу, становиться доступен каждому стансу класса."</dd>

  <dt>"Что делает метод «Class#allocate» ?"</dt>
  <dd>"Выделяет место для нового станса класса. Возвращаемый объект является экземпляром класса"</dd>

  <dt>"Что значит self?"</dt>
  <dd>"Текущий объект"</dd>

  <dt>"Что значит «Class::new», где «Class» это класс «Class»?"</dt>
  <dd>"Это метод класса объекта «Class» который создает новые классы"</dd>

  <dt>"Что означает знак «!» в конце метода?"</dt>
  <dd>"То, что надо работать с таким методом очень осторожно. Методы с таким наименованием, как правило, изменяют объект-приемник."</dd>

  <dt>"Что по умолчанию делает BasicObject#method_missing?"</dt>
  <dd>"Бросает исключение NoMethodError"</dd>

  <dt>"Что произойдет если вы попытаетесь объявить константу класса из вне этого класса?"</dt>
  <dd>"Константа будет определена, так как константы являются публично доступными и публично назначаемыми."</dd>

  <dt>"Что произойдет, если блоку передать два аргумента, когда принимает он только один?"</dt>
  <dd>"Ничего. Только первый аргумент будет передан блоку."</dd>

  <dt>"Что произойдет, если вы попытаетесь переопределить «BasicObject#__send__»?"</dt>
  <dd>"Руби вызовет предупреждение: «warning: redefining ""__send__"" may cause serious problems»"</dd>

  <dt>"Что произойдет, когда вы попытаетесь уменьшить уровень $SAFE?"</dt>
  <dd>"уровень $SAFE не может быть уменьшен - он может быть только увеличен"</dd>

  <dt>"Что происходит при подключении (extends) модуля к классу?"</dt>
  <dd>"Инстанс-методы (instance methods) модуля становятся методами-синглтона класса. ( методами класса ). Проще говоря - «extend» вызывает «include» для синглтон-класса объекта."</dd>

  <dt>"Что происходит при подключении (include) модуля к классу?"</dt>
  <dd>"Инстанс-методы (instance methods) модуля становятся доступными в качестве инстанс-методов (instance methods) класса. Проще говоря - «include» добавляет методы модуля объекту."</dd>

  <dt>"Что происходит, когда значение становится слишком большим для Fixnum?"</dt>
  <dd>"Оно автоматически преобразуются в Bignum."</dd>

  <dt>"Что такое $LOAD_PATH?"</dt>
  <dd>"Это предопределенная переменная ( «$:» синоним к «$LOAD_PATH» ), которая представляет собой массив, в котором содержаться имена каталогов и в котором при загрузке файлов производят поиск методы «load» и «require». В начальном состоянии «путь загрузки» содержит пути к стандартной библиотеке Ruby."</dd>

  <dt>"Что такое DSL?"</dt>
  <dd>"DSL - Domain Specific Language это API которое позволяет разработчикам решать задачи или предоставлять интерфейс на более понятном языке.  Программы, написанные с помощью хорошо продуманного DSL, легко читать, они говорят сами за себя. Классическим примером DSL является фреймворк для тестирования RSpec."</dd>

  <dt>"Что такое IO объект?"</dt>
  <dd>"IO обьект - это инстанс класса IO, который может быть использован для «чтения» или «записи» бинарных данных «в» или «из» файла."</dd>

  <dt>"Что такое eigenclass / metaclass / синглтон-класс?"</dt>
  <dd>"Синглтон-методы объекта (self.some_method) являются методами экземпляра (instance methods) анонимного класса (eigenclass), связанного с этим объектом"</dd>

  <dt>"Что такое singleton?"</dt>
  <dd>"Класс который может иметь один(ограниченное число) инстанс(ов)."</dd>

  <dt>"Что такое «Binding»?"</dt>
  <dd>"Объект класса Binding это контекст, который включает в себя переменные, методы, и т.д. Он хранит в себе это состояние и может предоставить к нему доступ."</dd>

  <dt>"Что такое «Struct» в Руби?"</dt>
  <dd>"Это особый класс в Руби, который создает специфические классы содержащие только набор переменных и методы доступа к ним. Такие классы называются структурными шаблонами (structure templates)."</dd>

  <dt>"Что такое «reflection API» в Руби?"</dt>
  <dd>"Это коллекция методов определенных в «Kernel», «Object», и «Module» которая позволяет программе просматривать / изменять свою структуру и состояние."</dd>

  <dt>"Что такое Утиная типизация ( Duck typing )?"</dt>
  <dd>"""Если объект ходит как утка, и крякает как утка, значит он — утка"". Мы работаем с обьектом на основании его поведения, а не принадлежности к классу."</dd>

  <dt>"Что такое итератор?"</dt>
  <dd>"Объект, который позволяет обходить элементы контейнера. В Ruby, итератором, считается любой метод, который использует оператор yield."</dd>

  <dt>"Что такое метапрограммирование?"</dt>
  <dd>"Метапрограммирование — вид программирования, связанный с созданием программ, которые порождают другие программы как результат своей работы"</dd>

  <dt>"Что такое метод Singleton?"</dt>
  <dd>"Метод, который доступен только на одном объекте."</dd>

  <dt>"Что такое метод мутатор?"</dt>
  <dd>"Метод, который изменяет внутреннее состояние объекта-приемника."</dd>

  <dt>"Что такое метод-предикат в контексте конвенций наименований методов Руби?"</dt>
  <dd>"Это метод, который отвечает на вопрос, поставленный именем метода. Предикаты обычно возвращают булевое значение."</dd>

  <dt>"Что такое модификаторы оператора (statement modifiers)?"</dt>
  <dd>"Условие, которое следует после выполняемой части оператора. (Например «x = 1 if a == true»)"</dd>

  <dt>"Что такое символ/symbol?"</dt>
  <dd>"Символы являются скалярным значением обьекта. Их используют в качестве идентификаторов для отображения неизменяющихся строк что бы зафиксировать внутреннее значение."</dd>

  <dt>"Является ли блок объектом?"</dt>
  <dd>"Нет, блок синтаксическая структура интерпретатора. Блок может быть преобразован в объект Proc."</dd>

  <dt>"Является ли метод объектом?"</dt>
  <dd>"Нет, однако, объект Method конечно, объект"</dd>

  <dt>"Являются ли методы экземпляра публичными/public или приватными/private?"</dt>
  <dd>"По умолчанию они являются открытыми/public, но вы можете изменить их видимость при помощи Module#private, Module#protected или снова сделать их открытыми/public Module#public."</dd>
</dl>

---

#### "Rails"
<dl>
  <dt>"Assets pipeline - какие его функции, назначение?"</dt>
  <dd>"У asset pipeline  есть три цели: прекомпиляция (precompile), конкатенация (concatinate) и минификация (minify) asset в один файл. Или другими словами: он просто берет все ваши stylesheets, javascript и images и любый другие файлы, которые вы захотите, прекомпилирует их ( из SASS в CSS ) сцепливает их в один файл (если это возможно), убирает пробелы и помещает в папку public/assets."</dd>

  <dt>"Big O notation - что это?"</dt>
  <dd>"Big O нотация расскажет вам, как зависит сложность алгоритма от того, что вы ему передаете на вход. Важно понимать, что Big O описывает только самый худший случай. O(1) - константа. O(n) - линейная зависимость. O(n^2) - квдаратичная зависимость (при каждом увеличении входных параметров - время работы будет увеличиваться вдвойне). O(log n) - пример - бинарный поиск."</dd>

  <dt>"Http - stateless или statefull?"</dt>
  <dd>"Stateless. В HTTP подразумевается, что вся сессия — это атомарный запрос/ответ, и нет никаких переходов между состояниями. Каждый новый запрос реально новый и новый запрос не знает что было до него, если вы хотите передать что-то между запросами - для этого есть куки."</dd>

  <dt>"Length vs Size vs Count в ActiveRecord - назовите ключевые отличия."</dt>
  <dd>"«#.count» - подсчитывает количество элементов при помощи SQL COUNT запроса. «#.length» - всегда пытается загрузить коллекцию ассоциаций в память, а затем вернуть количество загруженных элементов. Помните, если вы загрузили коллекцию ассоциации, то он НЕ будет принудительно обновляться. «#.size» - этот метод является комбинацией из двух предыдущих. Если коллекция была уже загружена, он вернут ее длинну, точно так же как работает метод length. Если же нет - будет работать как count."</dd>

  <dt>"Length vs Size vs Count в руби - назовите ключевые отличия."</dt>
  <dd>"Length и Size - ""практически"" алиасы ( вызов на Fixnum length - вернет exception, а size - нет ).По конвеншену length  используется для строк, а size  - для массивов и тд.. Count - метод Enumerable, а length и size - нет. Count - обычно используется совместно с блоком или аргументами и возвращает количество совпадений"</dd>

  <dt>"Middleware stack (стека промежуточных программ) - опишите что это?"</dt>
  <dd>"В Rack существует понятие middleware (чем по сути и является сам фреймворк). Используя middleware (посредник/фильтр) можно изменить/подготовить запрос перед тем как он попадет в Application, аналогично и с ответом для клиента."</dd>

  <dt>"Public, Protected, Private?"</dt>
  <dd>"Public. Методы или переменные доступны из любого места в коде. Protected. Защищенные методы или переменные доступные только внутри класса, где они были объявлены или из его произвольных классов. Private. Закрытые методы или переменные доступны только внутри класса."</dd>

  <dt>"Scopes vs Class methods?"</dt>
  <dd>"Scope-ы используются в цепочных вызовах, так как с методах класса поставить условие или возвращаемое значение будет более трудозатратно. Так же скоупы возвращает chainable object - в этом и есть суть. Если scope возвращает конкретную запись или nil - то лучше использовать класс метод."</dd>

  <dt>"Strong Parameters - опишите основную идею."</dt>
  <dd>"Основная идея, которая лежит в основе Strong Parameters, заключается в переносе mass-assignment защиты из модели в контроллер, к которому он относится. Принцип этой идеи состоит в том, что вы в контроллере явно указываете какие параметры вы ожидаете и уже с ними работаете (для каждого контроллера или для каждого action-а можно явно определить список принимаемых параметров)."</dd>

  <dt>"В чем особенность Eager_load от других способов загрузки ассоциаций (опишите работу Eager_load)?"</dt>
  <dd>"Этот метод загружает ассоциации в одном запросе с использованием Left Outer Join , точно так же, как действует includes  в сочетании с references."</dd>

  <dt>"В чем особенность Includes от других способов загрузки ассоциаций (опишите работу Includes)? (AR)"</dt>
  <dd>"По умолчанию includes  действует точно так же, как и preload, но в случае наличия условия по ассоциированной таблице переключается на создание единственного запроса с LEFT OUTER JOIN (Eager_load)."</dd>

  <dt>"В чем особенность Joins от других способов загрузки ассоциаций (опишите работу Joins)?"</dt>
  <dd>"Создает запрос с использованием INNER JOIN. При этом, загружаются данные только из первой (исходной) таблицы. Кроме того, этот запрос может возвратить дублирующие друг друга записи. Стоит заметить, что после выполнения метода joins  вызов user.posts приведет в созданию еще одного запроса."</dd>

  <dt>"В чем особенность Preload от других способов загрузки ассоциаций (опишите работу Preload)?"</dt>
  <dd>"Этот метод загружает ассоциации в отдельном запросе. Т.к. preload всегда создает два отдельных запроса, то мы не можем использовать вторую таблицу в условии выборки."</dd>

  <dt>"Для чего нужны Scope-ы?"</dt>
  <dd>"Скоупинг позволяет определить часто используемые запросы, к которым можно обращаться как к вызовам метода. Все методы скоупов возвращают объект ActiveRecord::Relation ( что позволяет нам делать scope chain)."</dd>

  <dt>"Зачем нужен Flash.now?"</dt>
  <dd>"По умолчанию, добавление значений во flash делает их доступными для следующего запроса, но иногда хочется иметь доступ к этим значениям в том же запросе. ( Нужен для отображения сообщений через flash при использовании render или ajax. )"</dd>

  <dt>"Зачем нужны partials ( партиалы )?"</dt>
  <dd>"Частичные шаблоны - также называемые ""партиалы"" - являются еще одним подходом к разделению процесса рендеринга на более управляемые части. С партиалами можно перемещать код для рендеринга определенных кусков отклика в свои отдельные файлы."</dd>

  <dt>"Интеграционное тестирование (integration testing) - опишите: цели, задачи."</dt>
  <dd>"Интеграционное тестирование (тестирование сборки) - тестирование части системы, состоящей из двух и более модулей. Основная задача - поиск дефектов, связанных с ошибками в реализации и интерпретации взаимодействия между модулями. Основная разница между модульным и интеграционным тестированием состоит в типах обнаруживаемых дефектов. (покрытие интерфейсов)."</dd>

  <dt>"Как долго «живет» сессия?"</dt>
  <dd>"Время жизни куки, которая хранит идентификатор сессии по умолчанию составляет 0 секунд, т.е. кука храниться до того момента, как браузер будет закрыт. Это время можно изменить на стороне сервера."</dd>

  <dt>"Как создаются 7мь стандартных акшенов ресурса ( resources :auctions )?"</dt>
  <dd>"В результате комбинирования четырех (CRUD) маршрутов с различными методами HTTP-запросов(GET,PUT, POST,DELETE), вы получаете семь полезных перестановок. В обмен на это, вы соглашаетесь использовать строго определенные имена действий контроллера: index, create, show, update, destroy, new, edit."</dd>

  <dt>"Какие выиды тестирования вы знаете? ( назовите хотя бы три )"</dt>
  <dd>"Модульное тестирование (unit). Интеграционное тестирование (integration testing). Системное тестирование (system testing). Приемочное тестирование (acceptance testing). Так же есть тестирование производительности, стрес-тестирование, нагрузочное, тестирование совместимости."</dd>

  <dt>"Какие типы ассоциаций Rails вы знаете?"</dt>
  <dd>"Rails поддерживает шесть типов связей: belongs_to, has_one, has_many, has_many :through, has_one :through, has_and_belongs_to_many"</dd>

  <dt>"Когда нужно использовать ActiveRecord::IrreversibleMigration?"</dt>
  <dd>"Если ваша миграция не обратима вам следует вызвать ActiveRecord::IrreversibleMigration из вашего метода down. Если кто-либо попытается отменить вашу миграцию, будет отображена ошибка, что это не может быть выполнено."</dd>

  <dt>"Модульное тестирование (unit) - опишите: цели, задачи."</dt>
  <dd>"Модульное тестирование - это тестирование программы на уровне отдельно взятых модулей, функций или классов. Цель модульного тестирования состоит в выявлении локализованных в модуле ошибок в реализации алгоритмов, а также в определении степени готовности системы к переходу на следующий уровень разработки и тестирования. (чаще всего проводится по принципу ""белого ящика"")"</dd>

  <dt>"Назовите 4 различных способа загрузки ассоциаций?"</dt>
  <dd>"preload , eager_load , includes  и joins."</dd>

  <dt>"Назовите три принципа ООП."</dt>
  <dd>"Инкапсуляция, Наследование, Полифорфизм."</dd>

  <dt>"ООП знаете? Что это такое?"</dt>
  <dd>"Объектно-ориентированное программирование – парадигма программирования, в которой основными концепциями являются понятия объектов и классов. В языках с прототипированием (Java Script, к примеру) вместо классов используются объекты-прототипы."</dd>

  <dt>"Опишите проблему N+1"</dt>
  <dd>"Эта проблема возникает, при загрузке дочерних обьектов используя ассоциацию ( many  в one-to-many  ). Многие ORM , по умолчанию, реализуют ленивую загрузку - соответственно делается запрос на поиск одной записи для родительского обьекта и для КАЖДОЙ дочерней записи. Как вы понимаете, делая N+1  запрос вместо одного вы перенапрягаете БД, чего мы и должны избегать."</dd>

  <dt>"Опишите работу template inheritance?"</dt>
  <dd>"template inheritance позволяет контроллеру перемещаться по иерархии в поисках нужного темплейта. Т.О. если контроллер не найдет подходящего темплейта в своей папке, то он обратится к папке родительского класса в поисках нужного файла и т.д."</dd>

  <dt>"Отличие Render от Redirect?"</dt>
  <dd>"Простыми словами надо понимать, что render - говорит какую вьюху (или иной ресурс) использовать в создании ответа. Метод redirect_to делает нечто полностью отличное - он говорит браузеру послать новый запрос по другому URL!"</dd>

  <dt>"Правильно ли использовать код приложения в миграциях? и почему?"</dt>
  <dd>"Нет. Использование кода в миграциях недопустимо - Время идет, код меняется и изменив код можно добиться того, что миграции с нуля вообще не запустятся. Используйте, например, временные Rake задачи для изменения имеющихся данных (главное их потом не забыть запустить!) или SQL код внутри миграций."</dd>

  <dt>"Приемочное тестирование (acceptance testing) - опишите: цели, задачи."</dt>
  <dd>"Приемочное тестирование (Acceptance testing) - тестирование готового продукта конечными пользователями в реальном окружении. Приемочные тесты разрабатываются пользователями (обычно в виде сценариев)."</dd>

  <dt>"Разница между HTTP-методами GET и POST?"</dt>
  <dd>"GET передает данные серверу с помощью URL, а POST передает данные, используя тело HTTP-запроса."</dd>

  <dt>"Системное тестирование (system testing) - опишите: цели, задачи."</dt>
  <dd>"Основная задача системного тестирования - выявление дефектов, связанных с работой системы в целом: 1) отсутствующая или неверная функциональность 2) неверное использование ресурсов системы 3) непредусмотренные комбинации данных пользовательского уровня 4) несовместимость с окружением. Системное тестирование производится над проектом в целом с помощью метода «черного ящика»"</dd>

  <dt>"Сколько примерно будет 2^32?"</dt>
  <dd>"Ответ «около четырех миллиардов» является исчерпывающим."</dd>

  <dt>"Хелперы в rails"</dt>
  <dd>"Хелперы это специальные методы которые содержаться в файлах app/helpers (если специально обозвать метод то можено создать и в контроллере хелпер ) - часто используются в шаблонах, для генерации различного html кода или для доступа к переменным контроллера. Помимо этих хелперов есть уже встроенные хелперы в rails. Хелперы позволяют красиво и гармонично добавить некую логику в ваш HTML код тем самым не делая его грязным."</dd>

  <dt>"Чем отличается процедурный подход от объектно-ориентированного?"</dt>
  <dd>"Процедурный подход предоставляет возможность программисту определять каждый шаг в процессе решения задачи. Задачи разбиваются на шаги и решаются шаг за шагом. ООП предполагает заключение внутри одного класса, как данных, так и методов их обработки."</dd>

  <dt>"Что выведет выдает rake routes?"</dt>
  <dd>"Эта команда напечатают все ваши маршруты, в том же порядке, что они появляются в routes.rb. Для каждого маршрута вы увидите: 1. Имя маршрута (если имеется) 2. Используемый метод HTTP (если маршрут реагирует не на все методы) 3. Шаблон URL 4. Параметры роутинга для этого маршрута."</dd>

  <dt>"Что за что отвечает в MVC?"</dt>
  <dd>"В шаблоне MVC, как следует из названия, есть 3 основных компонента: модель, представление и контроллер."</dd>

  <dt>"Что значит double render error? ( ошибки двойного рендера )"</dt>
  <dd>"Данный вид ошибки проиходит когда процесс рендеринга уже начат и мы пытаемся вызвать еще один render/redirect (ошибка происходит когда мы вызываем два раза подряд ""render"" в контроллере ). Важно понимать, что запустить рендеринг страницы можно только один раз ( Соответственно - вызвать render/redirect в экшене контроллера можно единожды ). Важно понимать, что вызов render в action-е не останавливает выполнение остального кода."</dd>

  <dt>"Что такое Active Record?"</dt>
  <dd>"Active Record это фреймворк который предоставляет нам несколько механизмов работы с бизнес-объектами, данные которых требуют постоянного хранения в базе данных. AR реализует: 1) Представления моделей и их данных. 2) Представления связей между этими моделями. 3) Представления иерархий наследования с помощью связанных моделей. 4) Валидации моделей до того, как они будут сохранены в базу данных. 5) Выполнения операций с базой данных в объктно-ориентированном стиле. Active Record ограждает вас от необходимости использования SQL во многих случаях."</dd>

  <dt>"Что такое Agile?"</dt>
  <dd>"Agile — семейство процессов разработки ( а не единственный подход в разработке программного обеспечения ) ориентированное на использование итеративной разработки, динамическое формирование требований и обеспечение их реализации в результате постоянного взаимодействия внутри самоорганизующихся рабочих групп. Отдавая предпочтение непосредственному общению, agile-подходы уменьшают объём письменной документации по сравнению с другими подходами."</dd>

  <dt>"Что такое BDD?"</dt>
  <dd>"BDD означает, что behaviour (выраженные в виде user stories) ведут вашу разработку. BDD концентруется на поведении приложения а не на его имплементации. BDD - это идея процесса разработки которая должна работать на уровне продукта в целом, где задача - упростить создание системы ( реализуете требования к поведению системы в виде человеко-читаемых спеков ). BDD скорее набор определенных тестов. Три принципа BDD. 1. What code does, not what it is. 2. Не пишите тест в обьеме большем, чем нужно для прохождения одного куска кода. 3. Тестировать только то, что можно проверить ( не надо тестировать случаи которых вообще не может быть в природе )."</dd>

  <dt>"Что такое Bundler?"</dt>
  <dd>"Это менеджер для управления gem-ами. Это менеджер для управления зависимостями gem-ов в ruby приложениях. Эта утилита позволяет легко устанавливать необходимые gem-ы для вашего приложения, при этом вовсе не зависеть от установленных в системе."</dd>

  <dt>"Что такое CRUD?"</dt>
  <dd>"В любом ресурсе есть набор экшенов, которые отвечают за манипуляцию с этим ресурсом. CRUD  это набор экшенов Create, Read, Update, Destroy."</dd>

  <dt>"Что такое CSRF?"</dt>
  <dd>"CSRF означает Cross-site request forgery (Межсайтовая подделка запроса). В отличие от XSS  CSRF  не пытается украсть вашу приватную информацию для входа куда-либо. CSRF  предполагает, что вы уже вошли авторизованны на этом сайте ( например на платежной системе ) и, когда вы посещаете сайт злоумышленника, то отправляется запрос, от вашего имени но без вашего ведома."</dd>

  <dt>"Что такое Continuous Integration (CI)?"</dt>
  <dd>"Continuous Integration, или для краткости CI – это особый принцип разработки программного обеспечения, который может очень сильно упростить вам жизнь. Если на пальцах, то система CI – это некая программа, которая следит за вашим Source Control, и при появлении там изменений автоматически стягивает их, билдит, гоняет тесты (конечно, если их пишут) и возможно делает кое-что ещё. В случае же неудачи она дает об этом знать всем заинтересованным лицам, в первую очередь – последнему коммитеру."</dd>

  <dt>"Что такое Decorator?"</dt>
  <dd>"Декоратор (англ. Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности."</dd>

  <dt>"Что такое Flash?"</dt>
  <dd>"Flash это специальная часть сессии, которая очищается ПРИ каждом запросе ( при каждом redirect-е )."</dd>

  <dt>"Что такое GEM?"</dt>
  <dd>"Технически файл с расширением .gem  представляет собой обычный архив, внутри которого находится файл спецификации и исходный код библиотеки в состоянии на момент релиза."</dd>

  <dt>"Что такое Gemfile?"</dt>
  <dd>"Gemfile  приложения - манифест файл, находящийся в корне Rails приложения, в котором и перечислены все необходимые для приложения gem-ы."</dd>

  <dt>"Что такое KISS?"</dt>
  <dd>"KISS - Keep it short and simple — «делай короче и проще». Это процесс и принцип проектирования в основу которого заложено утверждение, что большинство систем работают лучше, если они просты в использовании. Исходя из этого, простота дожна быть основной целью в области дизайна ПО и нужно стараться избегать ненужных усложнений во время проктирования."</dd>

  <dt>"Что такое MVC?"</dt>
  <dd>"Model-View-Controller – схема использования шаблонов проектирования, с помощью которых модель данных приложения, пользовательский интерфейс (UI) и взаимодействие с пользователем раздалены на 3 отдельных компонента так, что модификация одного из компонентов оказывает минимальное воздействие на остальные."</dd>

  <dt>"Что такое ORM в Rails?"</dt>
  <dd>"Паттерн проектирования, который сводится к достаточно простой вещи — представлению Таблиц в виде классов, строк как объектов, столбцов в виде свойств объектов. С использованием ORM, свойства и взаимоотношения этих объектов приложения могут быть с легкостью сохранены и получены из базы данных без непосредственного написания выражений SQL."</dd>

  <dt>"Что такое REST?"</dt>
  <dd>"REpresentation State Transfer — представление состояния, это один из подходов для предоставления данных. REST подразумевает такое понятие, как ресурс. Доступ к ресурсу и действиям над ним предоставляется по средствам специально регламентированных URL’ов, которые содержат в себе название ресурса и действие, которое мы хотим с этим ресурсом выполнить, например в нашем блогe В REST-контроллере, все методы должны называться уже установленным образом."</dd>

  <dt>"Что такое RVM?"</dt>
  <dd>"Ruby Version Manager Программа для управления версиями Ruby. Основные задачи: 1. Физическое разделение версий ruby и наборов гемсетов 2. Возможность иметь несколько версий ruby и переключаться между ними 3. Возможность для каждой версии ruby иметь несколько gemsets — наборов gems и переключаться между ними."</dd>

  <dt>"Что такое Refactoring?"</dt>
  <dd>"Процесс изменения программного кода, таким образом, что не изменяя внешнего поведения кода, улучшалась его внутренняя структура. Метод должен выполнять только ОДНО действие ( не надо делать длинные методы )."</dd>

  <dt>"Что такое Rspec?"</dt>
  <dd>"Rspec - это инструмент, помогающий программистам на Ruby писать тесты для своего кода."</dd>

  <dt>"Что такое SQL Injection."</dt>
  <dd>"Цель атаки в форме SQL инъекции - сделать запросы к базе данных, манипулируя с параметрами приложения. Популярная цель атак в форме SQL инъекций - обойти авторизацию. Другой целью является осуществление манипуляции с данными или чтение определенных данных."</dd>

  <dt>"Что такое Scrum?"</dt>
  <dd>"Scrum - одна из методологий гибкой разработки, которая позволяет в жёстко фиксированные и небольшие по времени итерации, называемые спринтами (sprints), предоставлять конечному пользователю работающее ПО с новыми возможностями, для которых определён наибольший приоритет. Возможности ПО к реализации в очередном спринте определяются в начале спринта на этапе планирования и не могут изменяться на всём его протяжении."</dd>

  <dt>"Что такое Sprint?"</dt>
  <dd>"Спринт это итерация в скраме, в ходе которой создаётся функциональный кусочек ПО. Спринт жёстко фиксирован по времени. На протяжении спринта никто не имеет права менять список требований к работе, внесённых в бэклог спринта."</dd>

  <dt>"Что такое TDD?"</dt>
  <dd>"TDD — методология (стиль) процесса разработки. TDD означает, что сначала пишется тест (который задает, что должно быть и как должна работать система), а потом уже пишется код. TDD работает на уровне написания кода, задача - упростить создание и изменение кода."</dd>

  <dt>"Что такое XSS?"</dt>
  <dd>"XSS  расшифровывается как межсайтовый скриптинг. Однако, несмотря на название, атака идет именно на ваш сайт, а не на какой-либо другой. XSS уязвимость позволяет выполнять JavaScript код на вашем сайте. Если хакер может выполнить JavaScript код, то он может увидеть ваши cookie. Если хакер может увидеть ваши cookie, то соответственно он может залогиниться от вашего имени."</dd>

  <dt>"Что такое rack ( config.rb file )?"</dt>
  <dd>"Rack - это интерфейс, который создан, чтобы обеспечить минимальное API для подключения веб-серверов поддерживающих Ruby (WEBrick, Mongrel и т.д.) и веб-фреймворками (Rails, Sinatra и др.). В нем реализован базовый функционал для работы с HTTP протоколом: утилиты для парсинга, классы Response, Request, Session и многое другое. config.ru - это стандартное конфигурационное имя файла для rackup ( где расширение ru - сокрашение от Rack Up )"</dd>

  <dt>"Что такое yeild?"</dt>
  <dd>"Yield  - (переводится как собрать) буквально означает: вместо этого слова в методе нужно поставить блок кода и выполнить метод в обычном режиме. Yield просто вызывает блок кода. Yield дергается всегда когда прописывается слово yield."</dd>

  <dt>"Что такое Инкапсуляция?"</dt>
  <dd>"Инкапсуляция – механизм, который объединяет данные и методы, манипулирующие этими данными и защищает их от внешнего вмешательства или неправильного использования. Можно сказать, что инкапсуляция подразумевает под собой сокрытие данных, что позволяет эти данные защитить."</dd>

  <dt>"Что такое Наследование?"</dt>
  <dd>"Наследование – процесс, с помощью которого, один объект может наследовать свойства другого объекта и добавлять к ним черты, характерные только для него."</dd>

  <dt>"Что такое Полифорфизм?"</dt>
  <dd>"Полифорфизм – свойство, позволяющее одно и то же имя использовать для решения несколькоих технически разных задач. Концепция полиморфизма: один интерфейс, множество реализаций. Это означает, что можно создать общий интерфейс для близких по смыслу действий. Классы с одинаковой спецификацией могут иметь различную реализацию."</dd>

  <dt>"Что такое вложенные ресурсы?"</dt>
  <dd>"- Это ресурсы которые логически подчинены другим ресурсам. ( где путь к ресурсу будет вылядеть вот так ""/magazines/:magazine_id/post/:id"" )"</dd>

  <dt>"Что такое класс? объект?"</dt>
  <dd>"Класс – модель еще не существующей сущности (объекта). Класс фактически описывает устройство объекта, являясь своего рода чертежом. Объект – совокупность данных и методов для их обработки. Класс – это тип данных, а объект – это экземпляр типа класса."</dd>

  <dt>"Что такое миграции?"</dt>
  <dd>"Миграции - это удобный способ изменять схему базы данных очень простым образом. Для создания миграции используется Ruby DSL. Поэтому вам не нужно писать SQL вручную, позволяя вашей схеме быть независимой от базы данных. Каждую миграцию можно рассматривать как новую «версию» базы данных. Схема изначально ничего не содержит, а каждая миграция изменяет ее, добавляя или убирая таблицы, столбцы или записи."</dd>

  <dt>"Что такое модели Active Record ( как создать такой класс и в чем его особенность )?"</dt>
  <dd>"Для создания модели Active Record необходимо создать подкласс ActiveRecord::Base. Это создаст модель AR, связав ее с таблицей в базе данных. Также появится способность связать столбцы каждой строки этой таблицы с атрибутами экземпляров вашей модели."</dd>

  <dt>"Что такое область видимости переменной?"</dt>
  <dd>"Область видимости переменной – место в программе, в которой доступно значение переменной. Каждая переменная имеет свою область видимости."</dd>

  <dt>"Что такое сессии? Где хранятся сессии?"</dt>
  <dd>"Сессия (HTTP Session) – логический объект, позволяющий передавать данные между последовательными HTTP-запросами от одного пользователя. Сессии создаются на стороне сервера и там же храняться. Другими словами, сессия – механизм, позволяющий однозначно идентифицировать браузер и созданный для этого браузера файл на сервере, в котором храняться переменные сеанса."</dd>

  <dt>"Что такое экземпляр ActiveRecord::Relation?"</dt>
  <dd>"Для получения объектов из базы данных Active Record предоставляет несколько методов поиска. В каждый метод поиска можно передавать аргументы для выполнения определенных запросов в базу данных без необходимости писать на чистом SQL. Все эти методы возвращают экземпляр ActiveRecord::Relation, где ActiveRecord::Relation - это просто класс-билдер."</dd>

  <dt>"Шаблонизаторы. Приведите примеры и обьясните их назначение."</dt>
  <dd>"Шаблонизаторы позволяют с помощью специального синтаксиса вставлять в HTML блоки исполняемого кода, написанного на языке общего назначения. Родным способом генерации всевозможных HTML страничек в рельсах является использование Ruby Templating, ERb. Идея ERb достаточно проста – вы пишите HTML-код, попутно включая в него Ruby-вставки, которые в последствии будут заменены на результат вычисления выражения во вставке. <% … %> или <%= … %>. HAML - другой шаблонизатор который целиком написан на DSL так же отвечает за генерацию как динамического содержимого, так и, собственно, HTML-разметки."</dd>
</dl>

---

#### "Rake"
<dl>
  <dt>"Выполняет миграцию до версии указаной в ключе VERSION ( последовательность"</dt>
  <dd>"от более старой, текущей, до более новой, указаной в ключе VERSION )"</dd>

  <dt>"Где и как расположены rake задачи?"</dt>
  <dd>"Все пользовательские задания, задачи располагаются в подкаталоге lib/tasks вашего приложения, и имеют расширение .rake"</dd>

  <dt>"Дайте описание rake db:create"</dt>
  <dd>"Создание базы данных из config/database.yml для текущего Rails.env (используйте db:create:all чтобы создать все базы данных из конфига)"</dd>

  <dt>"Дайте описание rake db:create"</dt>
  <dd>"Создать БД"</dd>

  <dt>"Дайте описание rake db:create:all"</dt>
  <dd>"Создаёт все БД из настроек в файле config/database.yml"</dd>

  <dt>"Дайте описание rake db:drop"</dt>
  <dd>"Удалить(дропнуть) текущую БД"</dd>

  <dt>"Дайте описание rake db:drop:all"</dt>
  <dd>"Удалить(дропнуть) все БД указаные в настройках config/database.yml"</dd>

  <dt>"Дайте описание rake db:migrate"</dt>
  <dd>"Миграция базы данных с помощью сценария в db/migrate"</dd>

  <dt>"Дайте описание rake db:migrate"</dt>
  <dd>"Выполняет миграции используя скрипты из папки db/migrate. Можно указать версию миграции добавив ключ VERSION="</dd>

  <dt>"Дайте описание rake db:migrate:down"</dt>
  <dd>"Выполняет откат миграции до версии указаной в ключе VERSION"</dd>

  <dt>"Дайте описание rake db:migrate:redo"</dt>
  <dd>"Откатить одну миграцию и выполнить её заново ( эквивалентно rake db:rollback, rake db:migrate ). Если указан ключ VERSION выполнит rake db:migrate:down, rake db:migrate:up"</dd>

  <dt>"Дайте описание rake db:migrate:rollback"</dt>
  <dd>"Откатить схему на одну миграцию назад"</dd>

  <dt>"Дайте описание rake db:migrate_plugins RAILS_ENV=production"</dt>
  <dd>"Запуск миграций для production версии"</dd>

  <dt>"Дайте описание rake db:schema:dump"</dt>
  <dd>"Создаёт db/schema.rb файл из текущей схемы базы данных"</dd>

  <dt>"Дайте описание rake db:schema:load"</dt>
  <dd>"Загрузить db/schema.rb в базу данных"</dd>

  <dt>"Дайте описание rake db:seed"</dt>
  <dd>"Выполняет файл db/seeds.rb в который обычно ложат скрипт заполнения БД тестовыми данными"</dd>

  <dt>"Дайте описание rake db:setup"</dt>
  <dd>"Эквивалентно выполнению следующей цепочки комманд: rake db:create, rake db:schema:load, rake db:seed"</dd>

  <dt>"Дайте описание rake db:test:prepare"</dt>
  <dd>"Подготовить тестовую БД, перезалив туда схему"</dd>

  <dt>"Дайте описание rake db:version"</dt>
  <dd>"Возвращает текущую версию схемы"</dd>

  <dt>"Дайте описание rake doc:rails"</dt>
  <dd>"Создать HTML-версию документации по rails"</dd>

  <dt>"Дайте описание rake log:clear"</dt>
  <dd>"Урезать размер всех файлов «*.log» в папке «log/» до 0 байт."</dd>

  <dt>"Дайте описание rake test:functionals"</dt>
  <dd>"Запустить все functional тесты ( тесты контроллеров )"</dd>

  <dt>"Дайте описание rake test:integration"</dt>
  <dd>"Запустить все integration тесты ( тесты вьюх )"</dd>

  <dt>"Дайте описание rake test:units"</dt>
  <dd>"Запустить все unit тесты ( тесты моделей )"</dd>

  <dt>"Как увидеть все возможные rake задачи?"</dt>
  <dd>"Выполнив команду rake -T или rake --tasks можно увидеть список и описание всех возможных задач rake."</dd>
</dl>

---

#### "SQL"
<dl>
  <dt>"ALTER TABLE Студент ADD COLUMN[Группа]TEXT(5):"</dt>
  <dd>"Добавление поля ""Группа"";"</dd>

  <dt>"INSERT INTO Студент([Фамилия],[Имя],[Дата рождения])VALUES(""Петров"", ""Иван"", 24/11/81):"</dt>
  <dd>"Добавление в поля новых записей;"</dd>

  <dt>"LIKE - это оператор:"</dt>
  <dd>"Выполняющий сравнение строковых значений;"</dd>

  <dt>"Что делает слудующий запрос: SELECT Студент.* FROM Студент WHERE [Дата рождения] BETWEEN 01.11.79 AND 01.12.81 AND[Группа] IN ("1212","1213")</dt>
  <dd>"Выбор студентов, дата рождения которых лежит в диапазоне от 01.12.79 по 01.11.81, и они обучаются в одной из групп 1213, 1213;"</dd>

  <dt>"Блокировочные СУБД ( Принцип работы )?"</dt>
  <dd>"MSSQL: Принцип действия, в общем-то, ясен из названия - в основе лежит протокол двухфазной блокировки. Перед чтением или изменением объект (запись) блокируется. То есть другим транзакциям запрещается изменять или даже читать этот объект до тех пор, пока первая транзакция не закончит с ним работать."</dd>

  <dt>"В каком виде представляются реляционые базы данных?"</dt>
  <dd>"В виде таблицы."</dd>

  <dt>"В каком случае оператор Exist даст утвердительный ответ?"</dt>
  <dd>"Если соотнесенный подзапрос производит какой-либо вывод"</dd>

  <dt>"В чем отличие JOIN от INNER JOIN?"</dt>
  <dd>"Если вы использовали JOIN и не указали тип выборки - то по умолчанию будет использоваться INNER JOIN"</dd>

  <dt>"В чем отличие LEFT JOIN от RIGHT JOIN?"</dt>
  <dd>"RIGHT JOIN (или RIGHT OUTER JOIN) действует в противоположность LEFT JOIN - показывает все записи из правой (второй) таблицы и только совпавшие из левой (первой) таблицы."</dd>

  <dt>"В чем отличие LEFT OUTER JOIN от LEFT JOIN?"</dt>
  <dd>"Слово OUTHER - опциональное"</dd>

  <dt>"Версионные СУБД ( Принцип работы )?"</dt>
  <dd>"PostgreSQL: Принцип действия версионности основан на том, что транзакция, изменяя данные, порождает новую копию (версию) данных, с которой и работает. Другим транзакциям эта версия не видна, до тех пор, пока первая не зафиксируется. При этом даже после фиксации первой транзакции, устаревшая версия какое-то время сохраняется для корректной работы транзакций, стартовавших до завершения работы первой, но еще не успевших зафиксироваться."</dd>

  <dt>"Выберите правильный SQL запрос для вставки новой записи в таблицу ""Persons"", причём в поле ""LastName"" вставить значение ""Olsen""."</dt>
  <dd>"INSERT INTO Persons (LastName) VALUES (""Olsen"")"</dd>

  <dt>"Выберите правильный SQL запрос для вставки новой записи в таблицу ""Persons""."</dt>
  <dd>"INSERT INTO Persons VALUES (""Jimmy"", ""Jackson"")"</dd>

  <dt>"Выбор пяти первых фамилий студентов, упорядоченных по учебным группам:"</dt>
  <dd>"SELECT [Имя],[Фамилия]FROM Студент ORDER BY[Группа] LIMIT(5);"</dd>

  <dt>"Выделение неповторяющихся дат рождений студентов и присвоение им нового наименования:"</dt>
  <dd>"SELECT DISTINCT[Дата_рождения] As Юбилей FROM Студент;"</dd>

  <dt>"Для какого типа полей может быть использован условный оператор LIKE?"</dt>
  <dd>"Char или VarChar"</dd>

  <dt>"Для чего используется предложение GROUP BY в команде SELECT?"</dt>
  <dd>"Для определения подмножества значений в терминах другого поля."</dd>

  <dt>"Для чего нужны VIEW ( представления )?"</dt>
  <dd>"Представления добавляют уровень защиты данных (например, можно создать представление для таблицы, где пользователю, выполняющему SELECT над представлением, видны только сведения о зарплате. Представления могут скрывать сложность данных, комбинируя нужную информацию из нескольких таблиц. Представления могут скрывать настоящие имена столбцов, порой трудные для понимания, и показывать более простые имена."</dd>

  <dt>"За удаление полей таблицы отвечает команда:"</dt>
  <dd>"DROP"</dd>

  <dt>"Записи из двух таблиц объединяются, если:"</dt>
  <dd>"Поля содержат одинаковые значения."</dd>

  <dt>"Как вставить в таблицу Sales два числа – числовое, текстовое?"</dt>
  <dd>"INSERT INTO Sales VALUES (1001, ""Peel"");"</dd>

  <dt>"Как выбрать все записи из таблицы ""Persons"", где значение поля ""FirstName"" начинается с буквы ""a""?"</dt>
  <dd>"SELECT * FROM Persons WHERE FirstName LIKE ""a%"""</dd>

  <dt>"Как выбрать все записи из таблицы ""Persons"", где значение поля ""FirstName"" равно ""Peter"" и ""LastName"" равно ""Jackson""?"</dt>
  <dd>"SELECT * FROM Persons WHERE FirstName=""Peter"" AND LastName=""Jackson"""</dd>

  <dt>"Как выбрать все записи из таблицы ""Persons"", где значение поля ""FirstName"" равно ""Peter""?"</dt>
  <dd>"SELECT * FROM Persons WHERE FirstName=""Peter"""</dd>

  <dt>"Как выбрать все записи из таблицы ""Persons"", где значение поля ""LastName"" в алфавитном порядке находится между значениями ""Hansen"" и ""Pettersen""?"</dt>
  <dd>"SELECT * FROM Persons WHERE LastName BETWEEN ""Hansen"" AND ""Pettersen"""</dd>

  <dt>"Как выбрать все записи из таблицы ""Persons"", упорядоченных по полю ""FirstName"" в обратном порядке?"</dt>
  <dd>"SELECT * FROM Persons ORDER BY FirstName DESC"</dd>

  <dt>"Как выбрать все поля из таблицы ""Persons""?"</dt>
  <dd>"SELECT * FROM Persons"</dd>

  <dt>"Как выбрать колонку с названием ""FirstName"" из таблицы ""Persons""?"</dt>
  <dd>"SELECT FirstName FROM Persons"</dd>

  <dt>"Как вывести количество записей, хранящихся в таблице ""Persons""?"</dt>
  <dd>"SELECT COUNT(*) FROM Persons"</dd>

  <dt>"Как изменить значение ""Hansen"" на ""Nilsen"" в колонке ""LastName"", таблицы Persons?"</dt>
  <dd>"UPDATE Persons SET LastName=""Nilsen"" WHERE LastName=""Hansen"""</dd>

  <dt>"Как расшифровывается SQL?"</dt>
  <dd>"Структурированный язык запросов"</dd>

  <dt>"Как удалить записи, где значение поля ""FirstName"" равно ""Peter""?"</dt>
  <dd>"DELETE FROM Persons WHERE FirstName = ""Peter"""</dd>

  <dt>"Какая SQL команда используется для вставки данных в базу?"</dt>
  <dd>"INSERT INTO"</dd>

  <dt>"Какая SQL команда используется для выборки данных из базы?"</dt>
  <dd>"SELECT"</dd>

  <dt>"Какая SQL команда используется для обновления данных в базе?"</dt>
  <dd>"UPDATE"</dd>

  <dt>"Какая SQL команда используется для удаления данных из базы?"</dt>
  <dd>"DELETE"</dd>

  <dt>"Какая SQL команда используется для упорядочивания результатов?"</dt>
  <dd>"ORDER BY"</dd>

  <dt>"Какая команда SQL используется для редактирования данных в таблице?"</dt>
  <dd>"Update"</dd>

  <dt>"Какие действия можно выполнять, используя запросы?"</dt>
  <dd>"получить всю информацию в таблице или только ту информацию, которая отвечает поставленным условиям"</dd>

  <dt>"Какое SQL выражение используется для извлечения различных значений?"</dt>
  <dd>"SELECT DISTINCT"</dd>

  <dt>"Какой оператор обеспечивает соединение таблиц?"</dt>
  <dd>"Join"</dd>

  <dt>"Какой условный оператор позволяет вывести информацию из указанного диапазона?"</dt>
  <dd>"BETWEEN"</dd>

  <dt>"Команда FOREIGN KEY используется для:"</dt>
  <dd>"Связи с внешними таблицами;"</dd>

  <dt>"На что указывает оператор IS NULL?"</dt>
  <dd>"На отсутствие значения."</dd>

  <dt>"Назовите Оператор соединения таблиц - это:"</dt>
  <dd>"«INNER JOIN», «LEFT JOIN», «RIGHT JOIN», «FULL OUTHER JOIN»"</dd>

  <dt>"Назовите плюсы и минусы использования индексов в SQL?"</dt>
  <dd>"Базовые функции индексов: 1. увеличение скорости доступа к данным 2. поддержка уникальности данных. Недостатки: 1. индексы занимают дополнительное место на диске и в оперативной памяти. 2. замедляются операции вставки, обновления и удаления записей."</dd>

  <dt>"Обновление, замена значений полей записи:"</dt>
  <dd>"UPDATE"</dd>

  <dt>"Оператор IN выполняет:"</dt>
  <dd>"Проверку выражения на совпадение с любым из элементов списка;"</dd>

  <dt>"Оператор OR срабатывает когда ХОТЬ ОДНО условие истинно. AND когда ВСЕ условия истинны."</dt>
  <dd>"Истина"</dd>

  <dt>"Оператор, выполняющий проверку на диапазон значений:"</dt>
  <dd>"BETWEEN...AND;"</dd>

  <dt>"Оператор, вычисляющий количество выделенных записей в запросе:"</dt>
  <dd>"Count."</dd>

  <dt>"Оператор, определяющий поля, по которым выполняется упорядочениевыходных данных, порядок их следования соответствует старшинству ключей сортировки:"</dt>
  <dd>"ORDER BY."</dd>

  <dt>"Оператор, определяющий, должен ли подчиненный запрос возвращать какие-либо записи:"</dt>
  <dd>"EXISTS"</dd>

  <dt>"Оператор, позволяющий указать имена исходных таблиц, участвующих в формировании выборки, - это:"</dt>
  <dd>"FROM;"</dd>

  <dt>"Отбор студентов, у которых совпадает фамилия:"</dt>
  <dd>"SELECT*FROM WHERE[Фамилия]=[Фамилия]."</dd>

  <dt>"Предикат используется для:"</dt>
  <dd>"Ограничения числа возвращаемых записей."</dd>

  <dt>"С помощью какого аргумента можно избавиться от дублирования данных при создании запроса SQL?"</dt>
  <dd>"Distinct"</dd>

  <dt>"С помощью какой команды SQL можно добавить в таблицу новый столбец?"</dt>
  <dd>"Alter Table"</dd>

  <dt>"С помощью какой команды SQL можно удалить все содержание таблицы?"</dt>
  <dd>"Delete From"</dd>

  <dt>"Создание списка фамилий студентов с указанием среднего балла по каждому студенту:"</dt>
  <dd>"SELECT Фамилия, Avg(Результат) AS Средний_балл FROM РезультатыGROUP BY[№ зачетки]."</dd>

  <dt>"Удаление определенной записи в таблице:"</dt>
  <dd>"DELETE...FROM...WHERE;"</dd>

  <dt>"Чем отличаются HAVING от WHERE?"</dt>
  <dd>"Предложение HAVING должно содержать как минимум одну агрегатную функцию, если это не так, то лучше применять предложение WHERE. Предложение WHERE применимо к отдельным строкам, а предложение HAVING к группам строк."</dd>

  <dt>"Что выполняет команда Drop Table?"</dt>
  <dd>"Удаляет только пустую таблицу базы данных"</dd>

  <dt>"Что определяет предложение HAVING в команде SELECT?"</dt>
  <dd>"Критерии для удаления определенных групп записей из вывода запроса."</dd>

  <dt>"Что позволяет выполнить предложение Order By команды SELECT?"</dt>
  <dd>"Сортировать данные."</dd>

  <dt>"Что позволяет выполнить предложение Order By команды SELECT?"</dt>
  <dd>"Сортировать данные."</dd>

  <dt>"Что такое CREATE VIEW?"</dt>
  <dd>"Это представление - виртуальная таблица. В действительности представление – всего лишь результат выполнения оператора SELECT, который хранится в структуре памяти, напоминающей SQL таблицу"</dd>

  <dt>"Что такое CROSS JOIN?"</dt>
  <dd>"CROSS JOIN - выборка перекрестного соединения с перебором все вариантов. Тело результата логически формируется следующим образом. Каждая строка одной таблицы соединяется с каждой строкой второй таблицы, давая тем самым в результате все возможные сочетания строк двух таблиц"</dd>

  <dt>"Что такое FULL OUTHER JOIN?"</dt>
  <dd>"Полное внешнее объединение FULL OUTER JOIN производит выборку множество всех записей  в первой таблице и во второй таблице, с соответствующими записями с обеих сторон при их наличии. Если совпадения нет, отсутствует сторона будет содержать NULL."</dd>

  <dt>"Что такое HAVING"</dt>
  <dd>"HAVING нужен для отбора групп по условию. Его синтаксис аналогичен выражению WHERE и мало того их можно использовать вместе."</dd>

  <dt>"Что такое INNER JOIN?"</dt>
  <dd>"Внутреннее соединение INNER JOIN производит выборку только тех записей, которые соответствуют как в первой таблице, так и во второй таблице."</dd>

  <dt>"Что такое LEFT JOIN?"</dt>
  <dd>"LEFT JOIN используется для создания левого внешнего объединения, при котором все записи из первой (левой) таблицы включаются в динамический набор, даже если во второй (правой) таблице нет соответствующих им записей (вместо этой таблицы используется строка со всеми значениями установлеными в NULL)"</dd>

  <dt>"Что такое RIGHT JOIN?"</dt>
  <dd>"RIGHT JOIN используется для создания правого внешнего объединения, при котором все записи из второй (правой) таблицы включаются в динамический набор, даже если в первой (левой) таблице нет соответствующих им записей."</dd>

  <dt>"Что такое ROLE ( SQL )?"</dt>
  <dd>"Роль – это уникальный элемент базы данных, не принадлежащий пользователю. Ее можно создать с помощью команды CREATE ROLE, причем наименование роли не может совпадать с именем пользователя. При наличии привилегии CREATE ROLE пользователи также могут задавать привилегии. После создания роль становится частью заданного по умолчанию набора ролей."</dd>

  <dt>"Что такое SQL трансакция?"</dt>
  <dd>"SQL Транзакция - это неделимая, с точки зрения воздействия на СУБД, последовательность операций манипулирования данными. Для пользователя транзакция выполняется по принципу ""все или ничего"", т.е. либо транзакция выполняется целиком и переводит базу данных из одного целостного состояния в другое целостное состояние, либо, если по каким-либо причинам, одно из действий транзакции невыполнимо, или произошло какое-либо нарушение работы системы, база данных возвращается в исходное состояние, которое было до начала транзакции"</dd>

  <dt>"Что такое СУБД?"</dt>
  <dd>"Пакет программ, обеспечивающий средствами описания и обработки данных"</dd>

  <dt>"Что такое индексы (SQL)?"</dt>
  <dd>"Индекс — объект базы данных, создаваемый с целью повышения производительности поиска данных. Таблицы в базе данных могут иметь большое количество строк, которые хранятся в произвольном порядке, и их поиск может занимать много времени. Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и, таким образом, позволяет искать строки, удовлетворяющие критерию поиска. Ускорение работы с использованием индексов достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск"</dd>

  <dt>"Что такое ключ?"</dt>
  <dd>"Идентификатор, уникально идентифицирующий значения атрибутов некоторой записи об объекте."</dd>

  <dt>"Что такое репликация?"</dt>
  <dd>"Репликация - это набор технологий, позволяющий копировать, распространять и синхронизировать определенные типы объектов базы данных и связанных с ними данных и зависимостей между ними из одной базы данных в одну или несколько других баз данных в одном и том же экземпляре или в разных экземплярах SQL Server."</dd>

  <dt>"Что такое транзакция?"</dt>
  <dd>"Логическая единица работы, составленная из одного или нескольких предложений SQL, выполняемых одним пользователем."</dd>
</dl>
